<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>长歌行|makejiec</title>
  
  <subtitle>知行合一</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://makejiec.gitee.io/"/>
  <updated>2021-01-02T15:32:35.320Z</updated>
  <id>https://makejiec.gitee.io/</id>
  
  <author>
    <name>长歌行</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>“鼠“实不&quot;疫&quot;、“牛”转乾坤</title>
    <link href="https://makejiec.gitee.io/2021/01/02/20210101/"/>
    <id>https://makejiec.gitee.io/2021/01/02/20210101/</id>
    <published>2021-01-01T16:54:16.000Z</published>
    <updated>2021-01-02T15:32:35.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2021年新启程"><a href="#2021年新启程" class="headerlink" title="2021年新启程"></a>2021年新启程</h2><p><img src="https://ae05.alicdn.com/kf/Heeddf4d6c3444d54b92d3399c7842345C.png" alt="20210101"></p><a id="more"></a><blockquote><p>时隔一年的blog终于被我找回来了，当时在阿里云上搭建的，后来要考研没时间更新了，导致服务器到期了，数据没找到，后来考完后又搭建了一个<a href="https://www.hychange.cn/" target="_blank" rel="noopener">技术博客</a>。那时候边面试边记录学习的过程。再后来就是工作了，996、有时甚至加班到10-11点，属实没时间，周六周日只想休息，没时间来更新博客。<br><br>为什么要搭建博客？<br>答：因该时在我接触电脑时就有一个想发，搭建一个属于自己的网站，再加上自己之前就学过一些前端知识，网上也有很多搭建的文章，很快就能搭建起来，另外我的公众号也是要准备做出来的。</p></blockquote><p>2020年不平凡的一年让我很难忘，我的研究生学习生涯与与我失之交臂，并加入了996的职场中。碰到职场中一些奇怪的事、奇怪的领导、奇怪的同事。我想从金今年开始要每天记录一篇职场或者生活的日记，哪怕是简单一句抱怨。同时，公众号也要同步起来，记录自己的所见所闻，还有学习日志。<br></p><h3 id="回顾2020"><a href="#回顾2020" class="headerlink" title="回顾2020"></a>回顾2020</h3><p>正经人谁写日记。。。<br></p><p> 对于2021的期望，我觉得还是先总结下2020年。<br></p><p>一月：元旦和室友一起去楚河汉街跨年，人真多导致吃不到火锅，只能开车去江汉路那边吃了一饨，大概大就是我们最后一饨了，(从那个时候起，我和我的室友就再也没一起吃过饭了)，有点遗憾。我的一个室友早已入职，还有个室友和女朋友出去住了，寝室就我和另一个室友在一起住。（希望今年有机会一起吃饭）<br></p><p>二月：赶在武汉疫情前赶回老家了，还是挺幸运的。二月也是过春节的月份，由于新冠疫情全面爆发，在家里待到六月才出来<br></p><p>三月、四月、五月这三个月，在家完成毕业设计，还好今年所有的毕业设计都是在网上完成的，就连答辩也是。真的很银杏，期间也拿到几家offer，最好的一家在北京结果五月北京被禁止入京了，导致只能放弃那个不错的offer，来到深圳。<br></p><p>六月：一个人拖着行李来到深圳，看到了一线大城市的惊鸿一面了，便开始在这个陌生、年轻的城市留下了，开启了我的职业生涯<br></p><p>七月之后就是我的职业生活了，充满了心酸。由于刚开始所以天天加班学习，到后面开始能自己做出来一些了，这期间到处请教别人。<br></p><p>在职场的这几个月，我深深的感受到我从一个一个充满自信的，到一个每天只想早点下班的码农转变，这里就不想去吐槽我的领导。</p><h3 id="2021新的开始"><a href="#2021新的开始" class="headerlink" title="2021新的开始"></a>2021新的开始</h3><p>在一事无成的2020，钱没有存到，体重倒是涨了几十斤。愿新的一年能把我肥胖的身躯变苗条。</p><p>- <font size="5">换一部手机</font></p><p>- <font size="5">自己配一台好一点电脑</font></p><p>- <font size="5">减到130</font></p><p>- <font size="5">理财，争取今明两年攒一台车</font></p><p>- <font size="5"><del>每天更新一篇博客</del>一周三篇博客，记录技术和生活</font></p><p>- <font size="5">找一份不是996的工作（虽然不可能）</font></p><p>上面很多本来是2020年实现的，结果自己太懒。虽然不一定全都实现，但是flag还是要有的不一定会实现。<br></p><p>总之，希望在新的一年，专业知识能有很大的提升。能进我喜欢的公司工作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2021年新启程&quot;&gt;&lt;a href=&quot;#2021年新启程&quot; class=&quot;headerlink&quot; title=&quot;2021年新启程&quot;&gt;&lt;/a&gt;2021年新启程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ae05.alicdn.com/kf/Heeddf4d6c3444d54b92d3399c7842345C.png&quot; alt=&quot;20210101&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://makejiec.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="flag" scheme="https://makejiec.gitee.io/tags/flag/"/>
    
      <category term="年度计划" scheme="https://makejiec.gitee.io/tags/%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>c语言——内存对齐</title>
    <link href="https://makejiec.gitee.io/2020/03/19/20200319/"/>
    <id>https://makejiec.gitee.io/2020/03/19/20200319/</id>
    <published>2020-03-19T14:43:28.000Z</published>
    <updated>2020-03-19T14:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>什么是内存对齐？</p><p>不同类型的数据内存中按照一定的规则；而不是顺序一个接一个的排放。</p><a id="more"></a><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Demo_1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">short</span> b</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Demo_2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这两种类型所占的内存空间是否相同？为什么？</p><p>首先为什么需要内存对齐？</p><ul><li>CPU对内存的读取不是连续的，而是分块读取的，块的大小只能是1、2、4、8个字节，只能是2^n个字节。</li><li>当读取操作的数据未对齐，则需要两次总线周期来访问内存，所以性能就会折扣</li><li>某些硬件平台只能从规定的地址读取某些特定类型的数据，否则就会抛出硬件 异常。<br>例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Demo_3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>当CPU去读取Demo_3时，所占的内存是3个字节，但cpu每次只能读2^n个字节，所以就有两种读法，第一次读取1个字节，第二次读取两个字节，最后拼接下。可以看出非常好使时间。<br>而真实中cpu会去读取四个字节，这样耗时就会很少，但这样会多一个字节，这时cpu就会优化Demo_3这个结构体使其占用四个字节。</p><p>还有的硬件中规定：只能读/写偶地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Demo_3</span> <span class="title">s1</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Demo_3</span> <span class="title">s2</span>;</span></span><br></pre></td></tr></table></figure><p>s1.a是一个字节，s2.b是两个字节。当访问s1.a的地址是0xffffff00，可以访问，当访问s2.b时，地址是0xffffff01，此时地址就是奇地址，所以就会出现硬件异常，程序就崩溃了。<br>所以CPU就会去优化让0xffffff01地址空置，把s2.b放在0xffffff02处。</p><p>因此这里有个#pragma pack能够改变编译器的默认对齐方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Demo_1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">short</span> b</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Demo_2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><p>此时sizeof(struct Demo_1) = ?<br><br>sizeof(struct Demo_2) = ?</p><blockquote><p>struct占用的内存</p><ul><li>第一个成员起始于0偏移处</li><li>每个成员按其类型大小和指定对齐参数n中较小的一个进行对齐<br>  偏移地址和成员占用大小需对齐<br>  结构体成员的对齐参数为其所有成员使用的对齐参数的最大值</li><li>结构体总长度必须为所有对齐参数的整数倍</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Demo_1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">short</span> b</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(struct Demo_1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看下输出结果是多少？</p><p><img src="https://gitee.com//change1998/blogimag/raw/master/img/l1.png" alt></p><p>为什么是12不是8，这就是内存对齐了。</p><p>可以看一下网上的一道面试题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">short</span> a;</span><br><span class="line">    <span class="keyword">long</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S1</span> <span class="title">d</span>;</span></span><br><span class="line">    <span class="keyword">double</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S2</span> <span class="title">s2</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(struct S1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(struct S2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(s2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)&amp;(s2.d) - (<span class="keyword">int</span>)&amp;(s2.c));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别在vc6.0和linux下的gcc中输出的结果</p><p>vc6.0:</p><p><img src="https://gitee.com//change1998/blogimag/raw/master/img/l2.png" alt></p><p>gcc:</p><p><img src="https://gitee.com//change1998/blogimag/raw/master/img/l3.png" alt></p><p>很奇怪吧，为什么不一样。后来查了下资料，发现在gcc编译器中不允许自定义的字节对齐，只能进行4个字节对齐。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存对齐&quot;&gt;&lt;a href=&quot;#内存对齐&quot; class=&quot;headerlink&quot; title=&quot;内存对齐&quot;&gt;&lt;/a&gt;内存对齐&lt;/h2&gt;&lt;p&gt;什么是内存对齐？&lt;/p&gt;
&lt;p&gt;不同类型的数据内存中按照一定的规则；而不是顺序一个接一个的排放。&lt;/p&gt;
    
    </summary>
    
      <category term="c语言" scheme="https://makejiec.gitee.io/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://makejiec.gitee.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
      <category term="编程剖析" scheme="https://makejiec.gitee.io/tags/%E7%BC%96%E7%A8%8B%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络编程</title>
    <link href="https://makejiec.gitee.io/2020/03/08/20200308-4/"/>
    <id>https://makejiec.gitee.io/2020/03/08/20200308-4/</id>
    <published>2020-03-08T01:30:27.000Z</published>
    <updated>2020-03-10T09:44:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>说起TCP那必须就得了解TCP三次握手、四次挥手了。关于怎么连接的下面图可以很好的解释：</p><a id="more"></a><meta name="referrer" content="no-referrer"><blockquote><p>三次握手<br><img src="https://tva4.sinaimg.cn/mw690/006p97Wqgy1gcma883kbgj30sk0drdhr.jpg" alt="Linux_27"><br>四次挥手<br><img src="https://tva1.sinaimg.cn/mw690/006p97Wqgy1gcma97z6nfj30sd0ftact.jpg" alt="Linux_28"></p></blockquote><p>关于其中一些具体的信息，我在网上看到一篇博客写的特别好，所以我就不想写了。<a href="https://blog.csdn.net/u013256816/article/details/84001583#comments" target="_blank" rel="noopener">一文详解TCP</a></p><p>这篇博文写的特别好，包括三次握手、四次挥手的具体的过程，还有TCP滑动窗口、拥塞机制都还可以。</p><h3 id="TCP网络编程"><a href="#TCP网络编程" class="headerlink" title="TCP网络编程"></a>TCP网络编程</h3><p>在学习了前面的socket编程的一些基础那就可以开始自己尝试着写一些实际的编程了。<br>程序的实现框图：<br><img src="https://tvax3.sinaimg.cn/mw690/006p97Wqgy1gcmai2b4vxj30q40icwhd.jpg" alt="Linux_30"></p><p>实验代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*服务器端*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; fcntl.h&gt;   //for open</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;  //for close</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> portnumber 3333</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd,new_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span>  <span class="comment">//记录网络地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sin_size;</span><br><span class="line">    <span class="keyword">int</span> nbytes;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*服务器端开始建立sockfd描述符*/</span></span><br><span class="line">    <span class="keyword">if</span>((sockfd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>))==<span class="number">-1</span>) <span class="comment">//AF_INET:ipv4,SOCK_STREAM:tcp</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Socket error:%s\n\a"</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*服务器端填充sockaddr结构*/</span></span><br><span class="line">    bzero(&amp;server_addr,<span class="keyword">sizeof</span>(struct sockaddr_in));  <span class="comment">//初始化置0</span></span><br><span class="line">    server_addr.sin_family=AF_INET; <span class="comment">//Internet</span></span><br><span class="line">    server_addr.sin_addr.s_addr=htonl(INADDR_ANY); <span class="comment">//将本机的long数据转化为网络序</span></span><br><span class="line">    <span class="comment">//server_addr.sin_addr.s_addr=inet_addr("192.168.1.1");</span></span><br><span class="line">    server_addr.sin_port=htons(portnumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*绑定sockfd描述符到IP地址*/</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd,(struct sockaddr *)(&amp;server_addr),<span class="keyword">sizeof</span>(struct sockaddr))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Bind error:%s\n\a"</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置允许连接的最大客户端数*/</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sockfd,<span class="number">5</span>)==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Listen error:%s\n\a"</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">/*服务器阻塞，直到客户程序连接*/</span></span><br><span class="line">        <span class="keyword">if</span>((new_fd=accept(sockfd,(struct sockaddr *)(&amp;client_addr),&amp;sin_size))==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Accept error:%s\n\a"</span>,strerror(errno));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Server get connection from%s\n"</span>,inet_ntoa(client_addr.sin_addr));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((nbytes=read(new_fd,buffer,<span class="number">1024</span>))==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Read error:%s\n\a"</span>,strerror(errno));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[nbytes]=<span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server receiver %s\n"</span>,buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*这个通讯已经结束*/</span></span><br><span class="line">        close(new_fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*客户端*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; fcntl.h&gt;   //for open</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;  //for close</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> portnumber 3333</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*使用hostname查询host名字*/</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Usage:%s hostname \a\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((host=gethostbyname(argv[<span class="number">1</span>]))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Gethostname error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*客户程序开始建立sockfd描述符*/</span></span><br><span class="line">    <span class="keyword">if</span>((sockfd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>))==<span class="number">-1</span>)  <span class="comment">//AF_INET:ipv4,SOCK_STREAM:tcp</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Socket Error:%s\a\n"</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*客户端填充服务端的资料*/</span></span><br><span class="line">    bzero(&amp;server_addr,<span class="keyword">sizeof</span>(struct sockaddr_in));  <span class="comment">//初始化置0</span></span><br><span class="line">    server_addr.sin_family=AF_INET; <span class="comment">//Internet</span></span><br><span class="line">    server_addr.sin_port=htons(portnumber); <span class="comment">//将本机上的short数据转化为网络序</span></span><br><span class="line">    server_addr.sin_addr=*((struct in_addr *)host-&gt;h_addr); <span class="comment">//IP地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*客户程序发起连接请求*/</span></span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd,(struct sockaddr *)(&amp;server_addr),<span class="keyword">sizeof</span>(struct sockaddr))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Connect Error:%s\a\n"</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*连接成功*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input char:\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*发送数据*/</span></span><br><span class="line">    fgets(buffer,<span class="number">1024</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    write(sockfd,buffer,<span class="built_in">strlen</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*结束通讯*/</span></span><br><span class="line">    close(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://tva4.sinaimg.cn/mw690/006p97Wqgy1gcmamc1z03j30ua0gudow.jpg" alt="Linux_33"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP协议&quot;&gt;&lt;a href=&quot;#TCP协议&quot; class=&quot;headerlink&quot; title=&quot;TCP协议&quot;&gt;&lt;/a&gt;TCP协议&lt;/h2&gt;&lt;p&gt;说起TCP那必须就得了解TCP三次握手、四次挥手了。关于怎么连接的下面图可以很好的解释：&lt;/p&gt;
    
    </summary>
    
      <category term="网络编程" scheme="https://makejiec.gitee.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="https://makejiec.gitee.io/tags/Linux/"/>
    
      <category term="网络编程" scheme="https://makejiec.gitee.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="TCP" scheme="https://makejiec.gitee.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核模块</title>
    <link href="https://makejiec.gitee.io/2020/03/08/20200308-1/"/>
    <id>https://makejiec.gitee.io/2020/03/08/20200308-1/</id>
    <published>2020-03-08T01:10:58.000Z</published>
    <updated>2020-03-10T08:55:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h2><p>Linux内核Linux内核的整体结构非常庞大,其包含的组件也非常多,如果把所有的组件都编译进内核文件,即：zImage或bzImage，但这样会导致一个问题：占用内存过多。所以就需要动态的添加某些组件，这些组件就是内核模块。特点：模块本身并不被编译到内核文件(zImage或bzImage)；可以根据需求，在<font color="red">内核运行期间动态的安装或卸载。</font><br>主要有解决两个问题：</p><ol><li>生成的内核文件过大</li><li>如果要添加或删除某个组件，需要重新编译整个内核<meta name="referrer" content="no-referrer"><a id="more"></a></li></ol><h3 id="内核开发"><a href="#内核开发" class="headerlink" title="内核开发"></a>内核开发</h3><p>先从一个简单的hello world开始:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; linux/module.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  printk(KERN_WARNING<span class="string">"Hello,world!\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  printk(KERN_INFO<span class="string">"Goodbye,world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure><p>可以看出和应用程序的区别了</p><ul><li>首先没有main函数</li><li>在应用程序用printf,这里用printk</li></ul><p>内核模块必要元素：<br><img src="https://tva1.sinaimg.cn/mw690/006p97Wqgy1gci5blwqpgj30ig09jwez.jpg" alt="Linux_8"></p><h3 id="内核模块编译"><a href="#内核模块编译" class="headerlink" title="内核模块编译"></a>内核模块编译</h3><p>在内核模块中用makefile编译</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内核模块&quot;&gt;&lt;a href=&quot;#内核模块&quot; class=&quot;headerlink&quot; title=&quot;内核模块&quot;&gt;&lt;/a&gt;内核模块&lt;/h2&gt;&lt;p&gt;Linux内核Linux内核的整体结构非常庞大,其包含的组件也非常多,如果把所有的组件都编译进内核文件,即：zImage或bzImage，但这样会导致一个问题：占用内存过多。所以就需要动态的添加某些组件，这些组件就是内核模块。特点：模块本身并不被编译到内核文件(zImage或bzImage)；可以根据需求，在&lt;font color=&quot;red&quot;&gt;内核运行期间动态的安装或卸载。&lt;/font&gt;&lt;br&gt;主要有解决两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成的内核文件过大&lt;/li&gt;
&lt;li&gt;如果要添加或删除某个组件，需要重新编译整个内核&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
    
    </summary>
    
      <category term="Linux内核" scheme="https://makejiec.gitee.io/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="Linux" scheme="https://makejiec.gitee.io/tags/Linux/"/>
    
      <category term="内核" scheme="https://makejiec.gitee.io/tags/%E5%86%85%E6%A0%B8/"/>
    
      <category term="kernel" scheme="https://makejiec.gitee.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络编程</title>
    <link href="https://makejiec.gitee.io/2020/03/08/20200308-3/"/>
    <id>https://makejiec.gitee.io/2020/03/08/20200308-3/</id>
    <published>2020-03-08T00:52:47.000Z</published>
    <updated>2020-03-10T09:42:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux网络编程"><a href="#Linux网络编程" class="headerlink" title="Linux网络编程"></a>Linux网络编程</h2><meta name="referrer" content="no-referrer">OSI七层模型应用层、表示层、会话层、传输层、网络层、数据链路层、物理层<a id="more"></a><p><img src="https://tvax3.sinaimg.cn/mw690/006p97Wqgy1gcm9podr2ij30oq0gx0uo.jpg" alt="Linux_26"></p><p>Linux网络协议（TCP/IP模型）<br>应用层、传输层、网络层、网络接口层<br><img src="https://tva4.sinaimg.cn/mw690/006p97Wqgy1gcm9b5ql72j30m80b4aa3.jpg" alt="Linux_25"><br>以太网协议——二层协议<br>IP——三层协议</p><p>网络层协议<br>Internet协议（IP）、网际报文协议（ICMP）、地址解析协议（ARP）</p><p>传输层协议<br>传输控制协议（TCP）、用户数据报文协议（UDP）</p><p>应用层协议<br>Telnet、FTP、TFTP、SMTP、DSN</p><p>以太网包<br><img src="https://tva4.sinaimg.cn/mw690/006p97Wqgy1gcmaggr3d7j30wc0doq5n.jpg" alt="Linux_29"></p><p><img src="https://tvax4.sinaimg.cn/mw690/006p97Wqgy1gcm9pzkegyj30z80f8ta3.jpg" alt="Linux_27"></p><p>IP协议包-无连接的传输服务</p><ul><li>数据传送</li><li>寻址</li><li>路由选择</li><li>数据报文的分段<br>IP协议头+IP数据</li></ul><p>TCP协议包位于IP数据中</p><p>UDP协议 无连接、不可靠</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Linux中的网络编程通过Socket(套接字)实现，socket文件被描述符<br>类型：</p><ul><li>流式套接字（SOCK_STREAM）<br>流式套接字面向连接的使用TCP协议</li><li>数据报套接字（SOCK_DGRAM）<br>无连接的服务，数据传输无序，不可靠，使用UDP协议</li><li>原始套接字（SOCK_RAM）<br>直接使用IP协议，用于新的网络协议的测试</li></ul><h4 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h4><p>在socket编程中，struct sockaddr用于记录网络地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u_short sa_family;</span><br><span class="line">    <span class="keyword">char</span> sa_data[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sa_family:协议族，AF_xxx，AF_INET（IP协议族）</li><li>sa_data:14字节的特定协议地址</li></ul><p>struct sockaddr_in也用于记录网络地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sin_family; <span class="comment">//协议族</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port; <span class="comment">//端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">//协议特定地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">//填0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>地址结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> s_b1,s_b2,s_b3,s_b4;</span><br><span class="line">        &#125;s_un_b;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> s_w1,s_w22;</span><br><span class="line">        &#125;s_un_w;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> s_addr;</span><br><span class="line">    &#125;S_un;</span><br><span class="line">&#125;IN_ADDR;</span><br></pre></td></tr></table></figure><p>地址转化：<br>IP地址通常由数字加点的形式（192.168.0.1）表示，struct in_addr中使用的IP地址是由32位的整数表示的，所以要转化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cp,struct in_addr* inp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span></span><br></pre></td></tr></table></figure><p>a表示ascii,n表示network.<br><br>inet_aton是将a.b.c.d形式的IP转换为32为的IP,存储在inp指针里面。<br><br>inet_ntoa是将32位IP转换为a.b.c.d的格式</p><p>字节序转换<br><br>网络字节序（big endian）<br><br>高位字节在低地址处，低字节的先传输。</p><ul><li>大端字节序：一个整数的高位字节(23<del>31bit)存储在内存的低地址处，低位字节(0</del>7bit)存储在内存的高地址处。</li><li>小端字节序：一个整数的高位字节(23<del>31bit)存储在内存的高地址处，低位字节(0</del>7bit)存储在内存的低地址处。</li></ul><p>现代PC大多采用小端字节序，因此其又被称为主机字节序。对应的，大端字节序也称为网络字节序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 主机字节序到网络字节序的转换,发送使用 */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span>  <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>  <span class="keyword">int</span> hostLong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> hostShort)</span></span>;</span><br><span class="line"><span class="comment">/* 网络字节序到主机字节序的转换，接受使用*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span>  <span class="keyword">int</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>  <span class="keyword">int</span> netLong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> netShort)</span></span>;</span><br></pre></td></tr></table></figure><p>使用主机名来访问:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* hostname)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">struct hostent</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* h_name; <span class="comment">//主机正式名</span></span><br><span class="line">    <span class="keyword">char</span>* h_aliases; <span class="comment">//主机别名</span></span><br><span class="line">    <span class="keyword">int</span> h_addrtype; <span class="comment">//主机类型 AF_INET</span></span><br><span class="line">    <span class="keyword">int</span> h_length; <span class="comment">//主机的地址长度</span></span><br><span class="line">    <span class="keyword">char</span>** h_addr_list; <span class="comment">//主机IP地址列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> h_addr h_addr_list[0] <span class="comment">//主机的第一个IP地址</span></span></span><br></pre></td></tr></table></figure><p>Socket编程步骤</p><ul><li>socket<br>创建套接字</li><li>bing<br>用于绑定IP地址和端口号到socket</li><li>connect<br>用于与服务器建立连接</li><li>listen<br>设置服务器能处理的最大连接要求</li><li>accept<br>用来等待来自客户端的socket连接请求</li><li>send<br>发送数据</li><li>recv<br>接受数据</li></ul><h3 id="TCP网络编程设计"><a href="#TCP网络编程设计" class="headerlink" title="TCP网络编程设计"></a>TCP网络编程设计</h3><p>基于TCP-服务器端<br>1.创建一个socket,用函数socket()<br>2.绑定IP地址、端口等信息到socket上，用bind()<br>3.设置允许最大连接数，用listen()<br>4.等待来自客户端的连接请求，用函数accept()<br>5.收发数据，用send()和recv(),或者read()和write()<br>6.关闭网络连接</p><p>基于TCP-客户端<br>1.创建一个socket,用函数socket()<br>2.设置要连接的服务器的IP地址和端口等属性<br>3.连接服务器，用connect()<br>4.收发数据，用send()和recv(),或者read()和write()<br>5.关闭网络连接</p><h3 id="UDP网络编程设计"><a href="#UDP网络编程设计" class="headerlink" title="UDP网络编程设计"></a>UDP网络编程设计</h3><p>基于UDP-服务器端</p><ol><li>创建一个socket,用函数socket()</li><li>绑定IP地址、端口等信息到socket上，用bind()</li><li>循环接受数据，用recvfrom()</li><li>关闭网络连接</li></ol><p>基于UDP-客户端</p><ol><li>创建一个socket,用函数socket()</li><li>设置要连接的服务器的IP地址和端口等属性</li><li>设置服务器的IP地址和端口等属性</li><li>发送数据，用sendto()</li><li>关闭网络连接</li></ol><h3 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h3><ul><li>循环服务器</li><li>并发服务器</li></ul><h4 id="UDP循环服务器"><a href="#UDP循环服务器" class="headerlink" title="UDP循环服务器"></a>UDP循环服务器</h4><p>UDP服务器每次从套接字上读取一个客户端的请求-&gt;处理-&gt;将结果返回给客户机<br>在一个线程里完成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sock();</span><br><span class="line">bind();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    recvfrom();</span><br><span class="line">    process();</span><br><span class="line">    sendto();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TCP循环服务器"><a href="#TCP循环服务器" class="headerlink" title="TCP循环服务器"></a>TCP循环服务器</h4><p>TCP循环服务器接受一个客户端的连接，然后处理，完成所有请求，断开连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sock();</span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    accept();</span><br><span class="line">    process();</span><br><span class="line">    close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TCP循环服务器一次只能处理一个客户端的请求，如果有一个客户端占住服务器，其他客户端都不能工作了。</p><h4 id="TCP并发服务器"><a href="#TCP并发服务器" class="headerlink" title="TCP并发服务器"></a>TCP并发服务器</h4><p>每一个客户机的请求并不有服务器直接处理，而是由服务器创建一个子线程来处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">socket();</span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    accept();</span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        process();</span><br><span class="line">        close();</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux网络编程&quot;&gt;&lt;a href=&quot;#Linux网络编程&quot; class=&quot;headerlink&quot; title=&quot;Linux网络编程&quot;&gt;&lt;/a&gt;Linux网络编程&lt;/h2&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
OSI七层模型
应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
    
    </summary>
    
      <category term="网络编程" scheme="https://makejiec.gitee.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="https://makejiec.gitee.io/tags/Linux/"/>
    
      <category term="网络编程" scheme="https://makejiec.gitee.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="TCP/IP" scheme="https://makejiec.gitee.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核</title>
    <link href="https://makejiec.gitee.io/2020/03/08/20200308-2/"/>
    <id>https://makejiec.gitee.io/2020/03/08/20200308-2/</id>
    <published>2020-03-08T00:50:01.000Z</published>
    <updated>2020-03-10T11:22:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Liux内核"><a href="#Liux内核" class="headerlink" title="Liux内核"></a>Liux内核</h2><h3 id="Linux体系结构"><a href="#Linux体系结构" class="headerlink" title="Linux体系结构"></a>Linux体系结构</h3><p>主要分为User Space、Kernel Space。</p><meta name="referrer" content="no-referrer"><a id="more"></a><p>User Space:</p><ul><li>User Applications</li><li>GNU C Library(glibc)c库</li></ul><p>Kernel Space:</p><ul><li>System Call Interface</li><li>Kernel</li><li>Architecture-Dependent Kernel Code（体系结构相关的代码）</li><li>Hardware Platform</li></ul><p>ARM7种工作模式？</p><h4 id="Linux内核架构"><a href="#Linux内核架构" class="headerlink" title="Linux内核架构"></a>Linux内核架构</h4><p>System Call Interface：系统调用接口<br>Process Management：进程管理<br>Virtual File System：虚拟文件系统，隐藏各种文件系统的，为文件操作提供统一的接口。Linux文件系统：Ext2、FAT、NFS、设备文件等<br>Memmory Management：内存管理<br>Network Stack：网络协议栈<br>Arch：体系结构相关的代码<br>Device Drivers：设备驱动</p><p>五大模块：进程管理、内存管理、文件系统、进程间的通信、网络接口</p><h3 id="Linux内核目录结构"><a href="#Linux内核目录结构" class="headerlink" title="Linux内核目录结构"></a>Linux内核目录结构</h3><ul><li>arch目录<br>arch(architecture),内核所支持的每种cpu体系，在该目录下都有对应的子目录</li><li>block目录<br>部分块设备驱动程序</li><li>crypto目录<br>加密、压缩、CRC校验算法</li><li>documentation<br>内核文档</li><li>drivers目录<br>设备驱动程序</li><li>fs目录<br>文件系统</li><li>include目录<br>头文件</li><li>lib目录<br>库文件代码</li><li>mm目录<br>用于实现内存管理中与体系结构无关的部分</li><li>net目录<br>网络协议实现代码</li><li>samples<br>一些内核编程的范例</li><li>scripts<br>配置内核的脚本</li><li>security<br>SElinux的模块</li><li>sound<br>音频设备驱动</li><li>usr<br>cpio命令实现，用于制作根文件系统</li><li>virt<br>内核虚拟机</li></ul><h3 id="Linux内核配置与编译"><a href="#Linux内核配置与编译" class="headerlink" title="Linux内核配置与编译"></a>Linux内核配置与编译</h3><p>1.清除零时文件、中间文件和配置文件。</p><ul><li>make clean<br>remove most generated files but keep the config</li><li>make mrproper<br>remove all generated files+config files</li><li>make distclean<br>mrproper+remove editor backup and patch files</li></ul><p>2.确定目标系统的软硬件配合，CPU、网卡、所支持的网络协议</p><p>3.配置内核</p><ul><li>make config:基于文本模式的交互式配置</li><li>make menuconfig:基于文本模式的菜单型配置</li><li>make oldconfig:使用已有的配置文件（.config），但是会询问新增的配置选项</li><li>make xconfig:图形化配置</li></ul><p>一般推荐make menuconfig</p><p>4.编译内核</p><ul><li>make zlmage</li><li>make bzlmage<br>区别：在x86平台，zlmage只能用于小于512k的内核</li></ul><p>获取编译详情：</p><ul><li>make zlmage V=1</li><li>make bzlmage V=1</li></ul><p>编译好的内核位于arch/cpu/boot/目录下</p><p>5.编译内核模块</p><ul><li>make modeules</li></ul><p>6.安装内核模块</p><ul><li>make modules_install<br>将编译好的内核模块从内核源代码目录copy到/lib/modules下</li></ul><p>7.制作init ramdisk</p><ul><li>mkinitrd initrd-$version $version<br>$version在/lib/modules下的目录得到</li></ul><h3 id="内核安装（x86）"><a href="#内核安装（x86）" class="headerlink" title="内核安装（x86）"></a>内核安装（x86）</h3><ol><li>cp arch/x86/boot/bzlmage 　　/boot/vmlinuz-$version</li><li>cp $initrd 　　/boot/</li><li>修改/etc/grub.conf或者/etc/lilo.conf</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Liux内核&quot;&gt;&lt;a href=&quot;#Liux内核&quot; class=&quot;headerlink&quot; title=&quot;Liux内核&quot;&gt;&lt;/a&gt;Liux内核&lt;/h2&gt;&lt;h3 id=&quot;Linux体系结构&quot;&gt;&lt;a href=&quot;#Linux体系结构&quot; class=&quot;headerlink&quot; title=&quot;Linux体系结构&quot;&gt;&lt;/a&gt;Linux体系结构&lt;/h3&gt;&lt;p&gt;主要分为User Space、Kernel Space。&lt;/p&gt;
&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
    
    </summary>
    
      <category term="Linux内核" scheme="https://makejiec.gitee.io/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="Linux" scheme="https://makejiec.gitee.io/tags/Linux/"/>
    
      <category term="内核" scheme="https://makejiec.gitee.io/tags/%E5%86%85%E6%A0%B8/"/>
    
      <category term="kernel" scheme="https://makejiec.gitee.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="https://makejiec.gitee.io/2020/03/07/20200307-5/"/>
    <id>https://makejiec.gitee.io/2020/03/07/20200307-5/</id>
    <published>2020-03-07T07:13:45.000Z</published>
    <updated>2020-03-10T09:12:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>线程（thread）与进程相比</p><ol><li>进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</li><li>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。<a id="more"></a><meta name="referrer" content="no-referrer">进程间的通信：无名管道、有名管道、信号、共享内存、消息队列、信号量、套接字进程：互斥量、读写锁、自旋锁、线程信号、条件变量</li></ol><p>Linux系统下多线程遵循POSIX线程接口——pthread。编写Linux下的多线程程序，需要使用头文件pthread.h，连接时需要使用库libpthread.a</p><h2 id="多线程的程序设计"><a href="#多线程的程序设计" class="headerlink" title="多线程的程序设计"></a>多线程的程序设计</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* tidp,<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>* attr,<span class="keyword">void</span>*(*start_rtn)(<span class="keyword">void</span>),<span class="keyword">void</span>* arg)</span></span></span><br></pre></td></tr></table></figure><ul><li>tidp：线程id</li><li>attr：线程属性（通常为空）</li><li>start_rtn：线程要执行的函数</li><li>arg：start_rtn的参数</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>首先libpthread.a不是linux系统中的库，所以编译时要加上-lpthread</p><ul><li>gcc filename -lpthread …</li></ul><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">myThread1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is the 1st pthread,created by wp.\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">myThread2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is the 2st pthread,created by wp.\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> id1,id2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建线程1*/</span></span><br><span class="line">    ret = pthread_create(&amp;id1, <span class="literal">NULL</span>, (<span class="keyword">void</span>*)myThread1,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Create pthread error!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建线程2*/</span></span><br><span class="line">    ret = pthread_create(&amp;id2, <span class="literal">NULL</span>, (<span class="keyword">void</span>*)myThread2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Create pthread error!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pthread_join(id1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(id2,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva3.sinaimg.cn/mw690/006p97Wqgy1gcliprl7d6j30fm08cdh0.jpg" alt="Linux_20"></p><p>向线程函数传递一个整形函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">create</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">    num=(<span class="keyword">int</span> *)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create parameter is %d \n"</span>,*num);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tidp;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> test=<span class="number">4</span>;  </span><br><span class="line">    <span class="keyword">int</span> *attr=&amp;test;  <span class="comment">//这里是关键，因为线程函数的返回值是一个指针这里必须转化一下</span></span><br><span class="line">    </span><br><span class="line">    error=pthread_create(&amp;tidp,<span class="literal">NULL</span>,create,(<span class="keyword">void</span> *)attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(error)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread_create is create is not created .. \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pthread_create is created ...\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tvax3.sinaimg.cn/mw690/006p97Wqgy1gcliuk2kfxj30co02pjrg.jpg" alt="Linux_21"></p><h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>进程中任何一个线程条用exit或_exit，那么整个进程都会终止。<br>正常退出的方式：</p><ul><li>线程从启动例程中返回</li><li>线程可以被另一个进程终止</li><li>线程自己调用pthread_exit</li></ul><h3 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*终止调用线程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span>* rval_ptr)</span></span></span><br></pre></td></tr></table></figure><p>rval_ptr：线程退出返回值的指针</p><h3 id="线程的等待"><a href="#线程的等待" class="headerlink" title="线程的等待"></a>线程的等待</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_join(pthread_t tid,void **rval_ptr)</span><br></pre></td></tr></table></figure><p>tid：等待退出的线程id<br>rval_ptr：线程退出的返回值的指针</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This in the thread：%d\n"</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pth;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;pth,<span class="literal">NULL</span>,thread,(<span class="keyword">void</span> *)(i));</span><br><span class="line"></span><br><span class="line">    pthread_join(pth,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"123\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This in the main: %d\n"</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tvax1.sinaimg.cn/mw690/006p97Wqgy1gcljwrmy94j30cx04ct8w.jpg" alt="Linux_23"></p><p>可以看出来先运行线程，在运行进程。如果去掉pthread_join(pth,NULL);后就会无序的输出：<br><img src="https://tva1.sinaimg.cn/mw690/006p97Wqgy1gclk2zwj8qj30cn03r0sx.jpg" alt="Linux_24"><br>pthread_join()和pthread_detach()的区别：<br><br>pthread_detach()即主线程与子线程分离，子线程结束后，资源自动回收。pthread_join()即是子线程合入主线程，主线程阻塞等待子线程结束，然后回收子线程资源。</p><h3 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取调用线程的thread identifier</span></span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><h3 id="线程清除"><a href="#线程清除" class="headerlink" title="线程清除"></a>线程清除</h3><p>pthread_cleanup_push到pthread_cleanup_pop之间的程序段中终止动作（包括调用pthread_exit()和异常终止，不包括return）都将执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将清除函数压入清除栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*rtn)(<span class="keyword">void</span>*),<span class="keyword">void</span>* arg)</span></span></span><br></pre></td></tr></table></figure><p>rtn：清除函数<br>arg：清除函数的参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将清除函数弹出清除栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span></span><br></pre></td></tr></table></figure><p>execute执行到pthread_cleanup_pop()时是否在弹出清理函数的同时执行该函数，非0：执行；0：不执行</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h2&gt;&lt;p&gt;线程（thread）与进程相比&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）&lt;/li&gt;
&lt;li&gt;进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。&lt;/li&gt;
&lt;li&gt;线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。&lt;/li&gt;
&lt;li&gt;但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。
    
    </summary>
    
      <category term="操作系统" scheme="https://makejiec.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="https://makejiec.gitee.io/tags/Linux/"/>
    
      <category term="操作系统" scheme="https://makejiec.gitee.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="线程" scheme="https://makejiec.gitee.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程间的通信</title>
    <link href="https://makejiec.gitee.io/2020/03/07/20200307-4/"/>
    <id>https://makejiec.gitee.io/2020/03/07/20200307-4/</id>
    <published>2020-03-07T07:13:39.000Z</published>
    <updated>2020-03-10T09:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息队列和信号量"><a href="#消息队列和信号量" class="headerlink" title="消息队列和信号量"></a>消息队列和信号量</h2><p>UNIX早起通信机制之一的信号能够传送信息量有限，管道则只能传送无格式的字节流，这无疑会给应用程序开发带来不变消息队列则克服了这一点。</p><a id="more"></a><p>消息队列就是一个消息<strong>链表</strong>。可以把消息看做一个记录，具有特定格式。进程可以向中按照一定的规则添加新消息；另一些进则可以从消息队列中读走消息。（和管道一样读完后消息就没有了，不像共享内存，写入还存在）</p><meta name="referrer" content="no-referrer">POSIX消息队列、System V消息队列<p>消息队列的内核持续性要求每个消息队列都在系统范围内对应唯一的键值。所以获取消息队列的描述字就必须提供该消息队列的键值。</p><h3 id="键值"><a href="#键值" class="headerlink" title="键值"></a>键值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="comment">/*返回文件名的键值*/</span></span><br><span class="line"><span class="keyword">key_t</span> ftok(<span class="keyword">char</span>* pathname,<span class="keyword">char</span> proj)</span><br><span class="line">pathname:文件名</span><br><span class="line">proj:项目名（不为<span class="number">0</span>即可）</span><br></pre></td></tr></table></figure><h3 id="打开-创建"><a href="#打开-创建" class="headerlink" title="打开/创建"></a>打开/创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">int</span> msgflg)</span></span></span><br></pre></td></tr></table></figure><p>key:键值，由ftok获得。<br>msgflg:标志位。<br>IPC_CREAT: 创建新的消息队列<br>IPC_EXCL: 与IPC_CREAT一起使用，如果要创建的消息队列存在，则返回错误。<br>IPC_NOWAIT：读写消息队列要求无法得到满足时，不阻塞。</p><p>返回值：与键值key相对应的消息队列描述字。</p><p>创建要求</p><ol><li>如果没有与key相对应的消息队列，并且msgflg中包含了IPC_CREAT标志位。</li><li>key的参数为IPC——PRIVATE。</li></ol><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*向消息队列发送一条消息*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid,struct msgbuf* msgp,<span class="keyword">int</span> msgsz,<span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">struct msgbuf</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> mtpye; <span class="comment">//消息类型&gt;0</span></span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1</span>]; <span class="comment">//消息数据的首地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*从msqid中读取msgtyp类型的消息，并把消息存储在msgp指向的msgbuf结构中*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid,struct msgbuf* msgp,<span class="keyword">int</span> msgsz,<span class="keyword">long</span> msgtyp,<span class="keyword">int</span> msgflg)</span></span></span><br></pre></td></tr></table></figure><p><strong>在成功读取的消息后，队列中这条消息将被删除</strong></p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_buf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">255</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_buf</span> <span class="title">msgbuf</span>;</span></span><br><span class="line"></span><br><span class="line">    key=ftok(<span class="string">"/tmp/5"</span>,<span class="string">'b'</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"key=[%x]\n"</span>,key);</span><br><span class="line">    msgid=msgget(key,IPC_CREAT|<span class="number">0666</span>);  <span class="comment">//通过文件对应</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(msgid==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    msgbuf.mtype = getpid();</span><br><span class="line">    <span class="built_in">strcpy</span>(msgbuf.data,<span class="string">"test change"</span>);</span><br><span class="line">    ret=msgsnd(msgid,&amp;msgbuf,<span class="keyword">sizeof</span>(msgbuf.data),IPC_NOWAIT);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"send message error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(&amp;msgbuf,<span class="number">0</span>,<span class="keyword">sizeof</span>(msgbuf));</span><br><span class="line">    ret=msgrcv(msgid,&amp;msgbuf,<span class="keyword">sizeof</span>(msgbuf.data),getpid(),IPC_NOWAIT);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"recv message error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"recv msg=[%s]\n"</span>,msgbuf.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>主要用于保护临界资源，进程可以根据它判断是否能够访问某些共享资源。除了访问控制外，还可用于进程同步。</p><h3 id="信号量分类"><a href="#信号量分类" class="headerlink" title="信号量分类"></a>信号量分类</h3><ul><li>二值信号灯：信号灯的值只能为0或1</li><li>计数信号灯：信号灯的值可取任意非负值</li></ul><h3 id="创建-打开"><a href="#创建-打开" class="headerlink" title="创建/打开"></a>创建/打开</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">ket_t</span> key,<span class="keyword">int</span> nsems,<span class="keyword">int</span> semflg)</span></span></span><br></pre></td></tr></table></figure><ul><li>key：键值，由ftok获得</li><li>nsems：指定打开或者新创建的信号灯集中将包含信号灯的数目</li><li>semflg：标识，同消息队列</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对信号量的操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid,struct sembuf *sops,<span class="keyword">unsigned</span> nsops)</span></span></span><br></pre></td></tr></table></figure><ul><li>semid：信号量集的ID</li><li>sops：是一个操作数组，表明要进行什么操作</li><li>nsops：sops所指向的数组的元素个数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> sem_num; <span class="comment">/*信号量数组下标，标识第几个信号量*/</span></span><br><span class="line">  <span class="keyword">short</span> sem_op; <span class="comment">/*信号量的操作，表示获取和释放*/</span></span><br><span class="line">  <span class="keyword">short</span> sem_flg; <span class="comment">/*标志*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sem_flg：信号操作标志</p><ul><li>IPC_NOWAIT：对信号的操作不满足时，semop()不会阻塞，并立即返回同时设定错误信息。</li><li>IPC_UNDO：程序结束时（不论正常或不正常）释放信号量，这样做偶的目的在于避免程序在异常情况下结束时未将锁定的资源解锁，造成该资源永久锁定</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;消息队列和信号量&quot;&gt;&lt;a href=&quot;#消息队列和信号量&quot; class=&quot;headerlink&quot; title=&quot;消息队列和信号量&quot;&gt;&lt;/a&gt;消息队列和信号量&lt;/h2&gt;&lt;p&gt;UNIX早起通信机制之一的信号能够传送信息量有限，管道则只能传送无格式的字节流，这无疑会给应用程序开发带来不变消息队列则克服了这一点。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://makejiec.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="https://makejiec.gitee.io/tags/Linux/"/>
    
      <category term="操作系统" scheme="https://makejiec.gitee.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程间的通信" scheme="https://makejiec.gitee.io/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程间的通信</title>
    <link href="https://makejiec.gitee.io/2020/03/07/20200307-3/"/>
    <id>https://makejiec.gitee.io/2020/03/07/20200307-3/</id>
    <published>2020-03-07T03:09:05.000Z</published>
    <updated>2020-03-10T09:10:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux进程间的通信"><a href="#Linux进程间的通信" class="headerlink" title="Linux进程间的通信"></a>Linux进程间的通信</h2><p>为什么要进行进程间的通信？</p><meta name="referrer" content="no-referrer">1. 数据的传输<br>一个进程需要将它的数据发送给另一个进程2. 资源的共享<br>多个进程之间共享同样的资源<a id="more"></a>3. 事件的通知<br>一个进程需要向另一个进程或另一组进程发送消息，通知它们发送了某种事件。4. 进程控制<br>有些进程希望完全控制另一个进程的执行（比如Debug进程），此时控制进程希望能够拦截另一个进程的所有操作并能够及时知道它的状态改变。Linux进程间的通信（IPC）由以下几部分发展而来的： - UNIX进程间的通信 - 基于System V进程间通信 - POSIX进程间的通信（可移植OS接口）<h3 id="IPC-进程间的通信-方式"><a href="#IPC-进程间的通信-方式" class="headerlink" title="IPC(进程间的通信)方式"></a>IPC(进程间的通信)方式</h3><ol><li>管道（pipe）和有名管道（FIFO)</li><li>信号（signal）</li><li>消息队列</li><li>共享内存</li><li>信号量</li><li>套接字（socket）</li></ol><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>管道：单向，先进先出，它把一个进程的输出和另一个进程的输入连接在一起。一个进程（写进程）在管道的尾部写入数据，另一个进程（读进程）从管道的头部读出数据。</p><h4 id="无名管道和有名管道"><a href="#无名管道和有名管道" class="headerlink" title="无名管道和有名管道"></a>无名管道和有名管道</h4><p>联系：<br>通信数据只存在于内存缓冲页面中；<br>都是半双工通信；</p><p>区别：<br>无名管道是无名的，有名管道是有名的；无名管道只能用于父子进程或兄弟进程之间的通信，而有名管道可用于任意两进程之间通信；无名管道是无形的，即无名管道的inode结构不是在磁盘上存储的，而是临时生成的，而有名管道的inode结点在磁盘上。</p><h4 id="管道的创建："><a href="#管道的创建：" class="headerlink" title="管道的创建："></a>管道的创建：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*无名管道（pipe）*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedis[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">当一个管道建立时，它会创建连个文件描述符：filedis[<span class="number">0</span>]用于读管道，filedis[<span class="number">1</span>]用于写管道</span><br><span class="line">close()函数用来关闭管道</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipe_fd)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe creat error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe creat success\n"</span>);</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tvax3.sinaimg.cn/mw690/006p97Wqgy1gcl7sd6x9yj30fk03pwey.jpg" alt="Linux_13"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*有名管道（FIFO）*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> cahr* pathname,<span class="keyword">mode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">一旦创建一个FIFO，就可用open打开它（FIFO就是一个文件），一般的文件访问函数（close、read、write等）都可以用于FIFO。</span><br><span class="line"></span><br><span class="line">打开FIFO时，非阻塞标志(O_NONBLOCK)</span><br><span class="line"><span class="number">1.</span>没有使用O_NONBLOCK：访问要求无法满足时进程将阻塞。比如师徒读取空的FIFO，将导致进程阻塞</span><br><span class="line"><span class="number">2.</span>使用O_NONBLOCK：访问无法满足时不阻塞，立刻出错返回，errno是ENXIO。</span><br></pre></td></tr></table></figure><h4 id="管道的读写"><a href="#管道的读写" class="headerlink" title="管道的读写"></a>管道的读写</h4><p>管道用于不同进程间通信。通常先创建一个管道，再通过fork函数创建一个子进程，该子进程会继承父进程所创建的管道。必须在系统调用fork()前调用pipe(),否则子进程将不会继承文件描述符。（应该会创建两个管道）<br><br>无名管道的读写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf_r[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span>* p_wbuf;</span><br><span class="line">    <span class="keyword">int</span> r_num;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf_r,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf_r));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建管道*/</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(pipe_fd)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe create error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*创建子进程*/</span></span><br><span class="line">    <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>) <span class="comment">//子进程读</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">        sleep(<span class="number">2</span>); <span class="comment">//保证父进程先运行，让父进程先写</span></span><br><span class="line">        <span class="keyword">if</span>((r_num=read(pipe_fd[<span class="number">0</span>],buf_r,<span class="number">100</span>))&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d numbers read from the pipe is %s\n"</span>,r_num,buf_r);</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>) <span class="comment">//父进程写</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(write(pipe_fd[<span class="number">1</span>],<span class="string">"Hello"</span>,<span class="number">5</span>)!=<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"parent weite1 Hello!\n"</span>);</span><br><span class="line">        <span class="keyword">if</span>(write(pipe_fd[<span class="number">1</span>],<span class="string">",world"</span>,<span class="number">6</span>)!=<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"parent write2 ,world!\n"</span>);</span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        waitpid(pid,<span class="literal">NULL</span>,<span class="number">0</span>);  <span class="comment">/*等待子进程结束*/</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva3.sinaimg.cn/mw690/006p97Wqgy1gcl7t748tgj30cr04qaaf.jpg" alt="Linux_14"></p><p>FIFO的读写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fifo_write.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO_SERVER <span class="meta-string">"/tmp/myfifo"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> w_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> nwrite;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*打开管道*/</span></span><br><span class="line">    fd=open(FIFO_SERVER,O_WRONLY|O_NONBLOCK,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please send something\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(w_buf,argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*向管道写入数据*/</span></span><br><span class="line">    <span class="keyword">if</span>((nwrite=write(fd,w_buf,<span class="number">100</span>))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(errno==EAGAIN)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The FIFO has not been read yet.Please try later\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"write %s to the FIFO\n"</span>,w_buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fifo_read.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO <span class="meta-string">"/tmp/myfifo"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf_r[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> nread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*创建管道*/</span></span><br><span class="line">    <span class="keyword">if</span>((mkfifo(FIFO,O_CREAT|O_EXCL)&lt;<span class="number">0</span>)&amp;&amp;(errno!=EEXIST))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't creat fifoserver\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Preparing for reading bytes...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf_r,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf_r));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*打开管道*/</span></span><br><span class="line">    fd=open(FIFO,O_RDONLY|O_NONBLOCK,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf_r,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf_r));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((nread=read(fd,buf_r,<span class="number">100</span>))==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno==EAGAIN)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"no data yet\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read %s from FIFO\n"</span>,buf_r);</span><br><span class="line">        sleep(<span class="number">1</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://tvax1.sinaimg.cn/mw690/006p97Wqgy1gcl8kdz6ykj30il0bsdha.jpg" alt="Linux_15"></p><h3 id="信号通信"><a href="#信号通信" class="headerlink" title="信号通信"></a>信号通信</h3><ol><li>用户按键产生信号。</li><li>硬件异常，除数为0、无效的访问等等。</li><li>进程用kill函数将信号发送给另个进程</li><li>用kill命令</li></ol><p>信号的类型：</p><ul><li>SIGHUP：从终端上发出的结束信号</li><li>SIGINT：来自键盘的中断信号（Ctrl-C）</li><li>SIGKILL：该信号结束接收信号的进程</li><li>SIGTERM：kill命令发出的信号</li><li>SIGCHLD：表示子进程停止或结束的信号</li><li>SIGSTOP：来自键盘（Ctrl-Z或调试程序的停止执行信号）</li></ul><h4 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h4><ol><li>忽略信号（SIGKILL和SIGSTOP这两种信号不能忽略）</li><li>执行用户希望的动作</li><li>执行系统默认动作（对大多数信号的系统默认动作是终止该进程）</li></ol><h4 id="信号发送"><a href="#信号发送" class="headerlink" title="信号发送"></a>信号发送</h4><p>发送函数kill和raise。<br>kill既可以向自身发送信号，也可以给其他进程发送信号。<br>raise只能向进程自身发送信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br></pre></td></tr></table></figure><ol><li>pid&gt;0  //将信号发送给ID为pid的进程</li><li>pid==0 //将信号发送给同组的进程</li><li>pid&lt;0  //将信号发送给其进程组ID等于pid绝对值的进程</li><li>pid==-1 //将信号发送给所有进程</li></ol><p>alarm函数<br><br>可以设置一个时间值，当时间到了时，产生SIGALRM信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span></span><br></pre></td></tr></table></figure><p>pause函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使调用进程挂起直至捕捉到一个信号*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//只有执行一个信号处理海曙后，挂起才结束</span></span></span><br></pre></td></tr></table></figure><h4 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h4><ol><li>使用简单的signal函数</li><li>使用信号集函数组</li></ol><p>signal函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signo,<span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">sighandler_t <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">sighandler_t</span> handler)</span></span></span><br></pre></td></tr></table></figure><p>func的值</p><ol><li>SIG_IGN:忽略此信号</li><li>SSSIG_DFL：按系统默认方式处理</li><li>信号处理函数名：使用该函数处理</li></ol><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> sign_no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sign_no==SIGINT)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I have get SIGINT\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sign_no==SIGQUIT)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I have get SIGQUIT\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Waiting for signal SIGINT or SIGQUIT \n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*注册信号处理函数*/</span></span><br><span class="line">    signal(SIGINT,my_func);</span><br><span class="line">    signal(SIGQUIT,my_func);</span><br><span class="line">    </span><br><span class="line">    pause();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先启动这个进程，进程出入等待状态：<br><img src="https://tva2.sinaimg.cn/mw690/006p97Wqgy1gcl9a0atzjj30e504baam.jpg" alt="Linux_16"><br>接着用<code>ps aux</code>查看进程PID<br><img src="https://tva2.sinaimg.cn/mw690/006p97Wqgy1gcl9dzon5mj30vc07y48u.jpg" alt="Linux_17"><br>然后用<code>kill -s SIGNQUIT 8923</code>发送退出信号<br><img src="https://tva2.sinaimg.cn/large/006p97Wqgy1gcl9gl6pk9j30hy05kn00.jpg" alt="Linux_18"></p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>被多个进程共享的一部分物理内存，访问速度快、不需要访问函数。<br>实现步骤:</p><ol><li>创建共享内存，使用shmget函数。</li><li>映射共享内存，将这段创建的共享内存映射到具体的进程空间去，使用shmat函数。</li></ol><p>创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">int</span> size,<span class="keyword">int</span> shmflg)</span></span></span><br></pre></td></tr></table></figure><p>key:0/IPC_PRIVATE,当key为IPC_PRIVATE，则函数shmget()将创建一块新的共享内存；如果key为0，而参数shmflg中又设置IPC_PRIVATE这个标志，则同样会创建一块新的共享内存。</p><p>返回值：成功，返回内存标识符；如果失败，返回-1。</p><p>映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">char</span>* shmaddr,<span class="keyword">int</span> flag)</span></span></span><br></pre></td></tr></table></figure><p>shmid:返回的共享存储表示符<br>flag: 方式，通常为0</p><p>返回值：成功，返回共享内存映射到进程中的地址；失败，返回-1。</p><p>解除映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intshmdt(cha* shmaddr)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERM S_IRUSR|S_IWUSR</span></span><br><span class="line"><span class="comment">/*共享内存*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">char</span> *p_addr,*c_addr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Usage:%s\n\a"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*创建共享内存*/</span></span><br><span class="line">    <span class="keyword">if</span>((shmid=shmget(IPC_PRIVATE,<span class="number">1024</span>,PERM))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Create Share Memory Error:%s\n\a"</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建子进程*/</span></span><br><span class="line">    <span class="keyword">if</span>(fork()) <span class="comment">//父进程写</span></span><br><span class="line">    &#123;   </span><br><span class="line">        p_addr=shmat(shmid,<span class="number">0</span>,<span class="number">0</span>);  <span class="comment">//第二参数0标识系统自动去找一个地址</span></span><br><span class="line">        <span class="built_in">memset</span>(p_addr,<span class="string">'\0'</span>,<span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(p_addr,argv[<span class="number">1</span>],<span class="number">1024</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);  <span class="comment">//释放资源，不关心终止状态</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//子进程读</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">//防止先运行</span></span><br><span class="line">        c_addr=shmat(shmid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Client get %s\n"</span>,c_addr);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://tva1.sinaimg.cn/mw690/006p97Wqgy1gclb3kqth0j30ec03ujrn.jpg" alt="Linux_19"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux进程间的通信&quot;&gt;&lt;a href=&quot;#Linux进程间的通信&quot; class=&quot;headerlink&quot; title=&quot;Linux进程间的通信&quot;&gt;&lt;/a&gt;Linux进程间的通信&lt;/h2&gt;&lt;p&gt;为什么要进行进程间的通信？&lt;/p&gt;
&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
1. 数据的传输&lt;br&gt;一个进程需要将它的数据发送给另一个进程
2. 资源的共享&lt;br&gt;多个进程之间共享同样的资源
    
    </summary>
    
      <category term="操作系统" scheme="https://makejiec.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="https://makejiec.gitee.io/tags/Linux/"/>
    
      <category term="进程间的通信" scheme="https://makejiec.gitee.io/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>进程控制程序设计</title>
    <link href="https://makejiec.gitee.io/2020/03/07/20200307-2/"/>
    <id>https://makejiec.gitee.io/2020/03/07/20200307-2/</id>
    <published>2020-03-07T02:23:38.000Z</published>
    <updated>2020-03-10T09:02:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程的程序设计</p><a id="more"></a><meta name="referrer" content="no-referrer"><h3 id="获取ID"><a href="#获取ID" class="headerlink" title="获取ID"></a>获取ID</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取本进程ID*/</span></span><br><span class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取父进程*/</span></span><br><span class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建子进程*/</span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>)</span><br><span class="line"><span class="comment">/*子进程的数据空间、堆栈空间都会从父进程拷贝，而不是共享。*/</span></span><br><span class="line"><span class="number">1.</span>在父进程中，fork返回新创建的子进程的PID</span><br><span class="line"><span class="number">2.</span>在进程中，fork返回<span class="number">0</span></span><br><span class="line"><span class="number">3.</span>如果出现错误，fork返回一个负值</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建进程*/</span></span><br><span class="line"><span class="keyword">pid_t</span> vfork(<span class="keyword">void</span>)</span><br><span class="line"><span class="comment">/*子进程与父进程共享数据段</span></span><br><span class="line"><span class="comment">子进程先运行，父进程后运行*/</span></span><br></pre></td></tr></table></figure><p>僵尸进程：子进程退出后，父进程没有调用wait()或 waitpid()获取子进程的状态信息，子进程的进程描述符仍保存在系统中，这种进程叫僵尸进程。</p><p>僵尸进程的危害：僵尸进程会一直占用进程号，系统能使用的进程号又是有限的，如果有大量的僵尸进程，会因为没有可用进程号导致无法创建新的进程。</p><p>孤儿进程：父进程结束退出，而它的子进程还在运行，这时的子进程就叫做孤儿进程。孤儿进程就被 init 进程（进程号为 1）收养，init 进程将对孤儿进程完成状态收集工作。</p><p>孤儿进程没有危害，因为被 init 进程托管了，init 进程会处理孤儿进程的收集工作。</p><p>fork与vfork的区别：</p><ol><li>fork：子进程拷贝父进程的数据段，代码段；vfork：子进程与父进程共享数据段</li><li>fork：父子进程的执行次序不确定；vfork：保证子进程先运行，在她调用exec()或exit()之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</li></ol><blockquote><p>为什么会有vfork，看到网上的一段话，因为以前的fork很傻，它创建一个子进程时，将会创建一个新的地址空间，并且拷贝父进程的资源，而往往在子进程中会执行exec()调用。这样，前面的拷贝工作就是白费力气了。这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中运行，所以子进程不能进行写操作，并且在儿子 霸占”着老子的房子时候，要屈老子一下了，让他在外面歇着（阻塞），一旦儿子执行了exec()或者exit()后，相当于儿子买了自己的房子了，这时候就相当于分家了。</p></blockquote><h3 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h3><p>exec用被执行的程序替换调用它的程序<br>fork创建一个新的进程，产生一个新的PID。<br>exec启动一个新的程序，替换原来的进程，因此进程的PID不会改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path,<span class="keyword">const</span> <span class="keyword">char</span>* arg1,...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path,cnost <span class="keyword">char</span>* arg1,...)</span></span></span><br><span class="line">path:不含路径，被执行程序名</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path,<span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span></span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    execl(<span class="string">"/bin/ls"</span>,<span class="string">"ls"</span>,<span class="string">"-al"</span>,<span class="string">"/etc/passwd"</span>,(<span class="keyword">char</span>*) <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/mw690/006p97Wqgy1gcl6ci3g0bj30hc04mjry.jpg" alt="Linux_11"></p><p>同样的execlp()和execlv()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    execlp(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="string">"-al"</span>,<span class="string">"/etc/passwd"</span>,(<span class="keyword">char</span>*) <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* argv[]=&#123;<span class="string">"ls"</span>,<span class="string">"-al"</span>,<span class="string">"/etc/passwd"</span>,(<span class="keyword">char</span>*) <span class="number">0</span>&#125;;</span><br><span class="line">    execv(<span class="string">"/bin/ls"</span>,argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果都一样。</p><h3 id="system函数"><a href="#system函数" class="headerlink" title="system函数"></a>system函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*调用fork产生子进程，由子进程来调用/bin/sh -c string来执行参数string的命令*/</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"ls -al /etc/passwd"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果与前面的都一样。但它不在主进程运行，他是在子进程中运行的。</p><h3 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h3><p>用fork创造一个进程，但执行顺序不同。所以有两种方法:</p><ol><li>用vfork让子进程先运行</li><li>在父进程中使用wait让父进程先等待其他进程运行退出时再运行。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*阻塞该进程，知道其某个子进程退出*/</span></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span>* status)</span><br></pre></td></tr></table></figure></li></ol><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pc,pr;</span><br><span class="line">    pc=fork();</span><br><span class="line">    <span class="keyword">if</span>(pc==<span class="number">0</span>) <span class="comment">//如果是子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is child proess with pid of %d\n"</span>,getpid());</span><br><span class="line">        sleep(<span class="number">5</span>); <span class="comment">//睡眠5秒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pc&gt;<span class="number">0</span>)  <span class="comment">//如果是父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        pr=wait(<span class="literal">NULL</span>); <span class="comment">//等待</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I catched a child process with pid of %d\n"</span>,pr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tvax4.sinaimg.cn/mw690/006p97Wqgy1gcl6osgym1j30d40400t5.jpg" alt="Linux_12"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程控制&quot;&gt;&lt;a href=&quot;#进程控制&quot; class=&quot;headerlink&quot; title=&quot;进程控制&quot;&gt;&lt;/a&gt;进程控制&lt;/h2&gt;&lt;p&gt;进程的程序设计&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://makejiec.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="https://makejiec.gitee.io/tags/Linux/"/>
    
      <category term="操作系统" scheme="https://makejiec.gitee.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="https://makejiec.gitee.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="https://makejiec.gitee.io/2020/03/07/20200307-1/"/>
    <id>https://makejiec.gitee.io/2020/03/07/20200307-1/</id>
    <published>2020-03-07T01:41:29.000Z</published>
    <updated>2020-03-10T08:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h2><p>进程是一个具有一定独立功能的程序的一次运行活动，具有动态性、并发行、独立行、异步行。</p><a id="more"></a><h3 id="程序与进程的区别"><a href="#程序与进程的区别" class="headerlink" title="程序与进程的区别"></a>程序与进程的区别</h3><p>我的通俗理解是程序是静态的，当程序运行起来就是进程了。</p><meta name="referrer" content="no-referrer"><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>就绪、执行、阻塞<br><br>首先程序处于就绪态，通过调度程序去占用cpu,这时候程序就处于执行态。在进程运行过程中cpu想从其他比如串口上读取数据，这时候串口上没有数据，进程就处于阻塞状态，等串口上有数据时，就会读取数据，整个I/O请求完成，程序就完成一次循环了又处于就绪状态。</p><p><img src="https://tva2.sinaimg.cn/mw690/006p97Wqgy1gcl4wxvqquj30gx0dd0u7.jpg" alt="Linux_9"></p><h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p>进程由 3 个部分组成，分别是程序代码、数据集、栈和进程控制块（Process Control Block）。<br><br>各自的作用如下：</p><ul><li>程序代码：描述了进程需要完成的功能。</li><li>数据集、栈：程序在执行时所需要的数据和工作区。</li><li>进程控制块：包含进程的描述信息和控制信息，它是进程存在的唯一标识。</li></ul><h3 id="进程ID"><a href="#进程ID" class="headerlink" title="进程ID"></a>进程ID</h3><p>进程的ID(PID):标识进程的唯一数字<br>父进程(PPID)<br>启动进程的用户ID(UID)</p><h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><p>两个或两个以上的进程，不能同时进入关于同一组共享变量的临界区域，否则可能发生与时间有关的错误，这种现象被称作进程互斥· 也就是说，一个进程正在访问临界资源，另一个要访问该资源的进程必须等待。</p><p>临界区：进程中访问临界资源的那段程序代码。<br><br>为实现对临界资源的互斥访问，应保证诸进程回车地进入各自临界区。</p><p>为实现进程互斥，可以利用软件的方法，也可以在系统中设置专门的同步机制来协调多个进程，但是所有的同步机制应该遵循四大准则：</p><ol><li>空闲让进：当临界资源处于空闲状态，允许一个请求进入临界区的进程立即进入临界区，从而有效的利用资源。</li><li>忙则等待：已经有进程进入临界区时，意味着相应的临界资源正在被访问，所以其他准备进入临界区的进程必须等待，来保证多进程互斥。</li><li>有限等待：对要求访问临界资源的进程，应该保证该进程能在有效的时间内进入临界区，防止死等状态。</li><li>让权等待：当进程不能进入临界区，应该立即释放处理机，防止进程忙等待。<br>早期解决进程互斥问题有软件的方法和硬件的方法，如：严格轮换法，Peterson的解决方案，TSL指令，Swap指令都可以实现进程的互斥，不过它们都有一定的缺陷，这里就不一一详细说明，而后来Dijkstra提出的信号量机制则更好的解决了互斥问题。<br>解决进程互斥还有管程，进程消息通信等方式。</li></ol><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>一组并发进程按一定顺序执行的进程称为进程间的同步。具有同步关系的一组并发进程称为合作进程，合作进程间互相发送的信号称为消息或事件。</p><p>实现进程同步的方法<br><img src="https://tvax4.sinaimg.cn/large/006p97Wqgy1gcl5attnx1j315o0nckcs.jpg" alt="Linux_10"></p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>按一定算法，从一组代运行的进程中选出一个来占有CPU运行<br><br><a href="https://blog.csdn.net/qq_35642036/article/details/82809812" target="_blank" rel="noopener">进程调度方式</a></p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个进程因竞争资源而形成的一种僵局，若无外力作用，这些进程都将永远不能在向前推进。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是进程？&quot;&gt;&lt;a href=&quot;#什么是进程？&quot; class=&quot;headerlink&quot; title=&quot;什么是进程？&quot;&gt;&lt;/a&gt;什么是进程？&lt;/h2&gt;&lt;p&gt;进程是一个具有一定独立功能的程序的一次运行活动，具有动态性、并发行、独立行、异步行。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://makejiec.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="https://makejiec.gitee.io/tags/Linux/"/>
    
      <category term="操作系统" scheme="https://makejiec.gitee.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="https://makejiec.gitee.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>记录人生第一次收获offer的艰辛</title>
    <link href="https://makejiec.gitee.io/2020/03/06/20200306/"/>
    <id>https://makejiec.gitee.io/2020/03/06/20200306/</id>
    <published>2020-03-06T00:44:01.000Z</published>
    <updated>2021-01-02T15:38:01.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试的酸甜苦辣"><a href="#面试的酸甜苦辣" class="headerlink" title="面试的酸甜苦辣"></a>面试的酸甜苦辣</h2><p>2020是一个充满无奈的年份，从疫情爆发后很多公司都取消春招了，然而每年应届毕业生都是再创新高。前几个月教育部发布的应届生人数达到了875万，这是多么恐怖的数字。即使研究生报名的人数多，再加上出国留学的几十万，还有今年的研究生扩招，但还有19届毕业生、那些二战三战的学生们。这该有多少人会面临就业压力。<br><br>我自己在找工作时就发现了今年的工作不好找切身体会啊，先说说自己的面试经历吧</p><a id="more"></a><h3 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h3><p>在我投简历之前，我参加了20届的研究生入学考试，在2月份分数就出来了。不出意料，考完我就预料到了，当时在考试时候，我就感觉到自己考得不很好，包括报考院校往年都是370左右的分数线（哪所就不说了），比往年低了20分，我还想二战，毕竟我底子还是可以的，除了今年的专业课没怎么复习意外炸了，其他的都还可以（当然别人也考得很好）。我的妈妈都想我去在租房二战，意味着我的家的又要多面临一年的压力，我只好承诺会边找工作然后今年继续来二战（具体不好说）。<br><br>二月份开始在智联招聘上投了差不多四五十家，刚开始几天很多直接是不合适（简历都没过），我当时第一体会到我爸说的“外面的钱不好挣，工作不好找的”，确实太难了，很多招聘工作上面要有经验，然后有项目开发等，我想我们一个应届生哪来折磨多的项目啊。我找了之前学习的实训的项目和毕业设计写在上面。过来几天后，打来第一家公司的电话，hr直接说我没有经验，要我去他们公司培训三个月，但是这三个月没工资。我说我考虑下，确实毕竟第一家，我相信后面还有多机会，这期间我也投了很多大厂的，参加的笔试（屏幕获取、摄像头、手机监控这些都是大厂笔试的三件套）也让我明白大小厂的差别。大厂看中基础，很多都是大学课堂上的问题，比如之前投的CVTE的笔试，里面就有线性代数的题目。所以说别再说大学学东西没用了，其实在找工作时就看的出来，平常我们都说大学只求60，多一分不要。我认为像我们的必修课程我们必须要学好，笔试时也能答的遂心应手。</p><p><strong>这里必须提一下，招聘软件上很多都是培训机构，在投简历时要看清楚了。(我就碰到好几家培训机构)</strong></p><p>小厂的就是要有经验，上来就能干活，毕竟养几个月的闲人还是没有这钱的。后来又打来一个电话问我能不能做测试岗，我的专业目标是嵌入式开发岗，目标是进芯片原厂。我说我目前只考虑Android开发和嵌入式，就说考虑下，留了个电话。之后又是一家北京的公司，面试的不是很理想，还有其他的原因没结果。在年级群里投的一家公司，也打电话做了笔试，我的室友也是这家（目前拿到测试的offer），我应聘的的开发岗，做操作系统的，还好学过一段时间的Linux，但毕竟不深入很多概念不懂。面试是视频会议，说实话能面试我很意外，我笔试完时我就感觉不太行，很多会的不太记得了，最后一道编程题，还没跑的就交了。并没抱什么打算，过了两天hr打电话说笔试结果可以进入面试，着实让我感到意外。面试的内容我说下：<br><br>一上来就问我项目，我说的是毕业设计，里面有些操作系统的知识，毕竟花了一段时间去研究了，但还是问了一些我没深入的细节比如：多线程，进程的问题，什么是僵尸进程？我当时就蒙了，听说了但就是想不起来，就乱扯了个。我这里面有个socket编程，处理机制用了epoll,就问了epoll_wait的最后一个参数-1代表什么意思，说实话这些我都之前上网查过，但是没记住。然后问我前几天笔试最后一道算法，找最长重复的字符串问题，我当时就慌了，我想我当时在下面真该查一下的。哎，还好只说下算法的思路，这我还是有的毕竟力扣没白刷，不会写代码思路还是手到擒来。最后就是问c语言方面的知识了，这里有一个知识就是strlen和sizeof这个每家都会问的问题，c语言内存分配堆栈问题，函数的参数入栈顺序，结构体、枚举、联合体等，还有条件编译，c和c++的区别，这问题把我问到了，毕竟有两年没写c++了就只知道个大概，没说清楚。之后就是期望薪资等问题了。<br><br>说实话面试结果自我感觉还是可以的，大部分都答上来了，过了两天后我问我室友你当时什么时候出面试结果，他说直接问的hr，后来我发给hr发来条短信了，等了几天没回我，我想应该凉了当时要了7k（其实很低了，我室友测试都是7k）。然后就是我拿offer这家了，一家小公司做摄像头开发的，可能我做的项目比较适合这家了都是摄像头的，hr直接邀电话面试，面试的大致内容：<br><br>也是上来做个自我介绍，然后就是你的学了哪些专业课程，接着是项目了。项目还好说毕竟有了前面的经验该踩的坑都填上了，但还是有一点没答上来，毕竟每个面试官问的都不一样，侧重点不一样，前一家就注重操作系统方面，这一家就侧重摄像头驱动方面，然后就是c语言，问了空指针、野指针的解决，这些都不是问题，还有strlen和sizeof了（又问了，可想多重要了），然后堆栈在内存中的分配了。<br><br>说实话这家问的c语言没难度，都很基础必须掌握的知识。接着问了我的学习成绩（我们班第一第二，哈哈），能上岗的时间，我说疫情结束，除了毕业设计就没有了事，然后就谈期望薪资，我有点不敢说，怕要高了（没自信，面试时就应该爽快点），我吞吐吞吐说出来8k以上吧，这个面试官很好就说别怕你说我会和领导商量的，最后他说我等下把他们公司的工资表发我让我参考下，就加了个微信，结果到了晚上，就直接发微信和我说老板同意了，给我开了个还算满意的工资了，之后就发电子offer了。<br><br>说到这里我就感叹这一个月的求职之路不容易啊，等了很多家公司没消息，笔试了很多家也没结果了。太难了！！！终于定心丸下来了，就算后面继续找也有退路了。</p><h3 id="对求职者的一些建议"><a href="#对求职者的一些建议" class="headerlink" title="对求职者的一些建议"></a>对求职者的一些建议</h3><p>拿到offer后接着又拿到了几家（不是很满意），hr叫我帮宣传下，我就给辅导员说了，我说这家公司招人，希望能给同学宣传下，后来就收到几份简历。说实话，看到简历第一眼我就没看下去了（这里是指开发岗的同学），要我是hr我看都不会看的，不过他们那种简历投国企还是有吸引力的，什么党员啊、获得奖学金什么的一大堆（吐槽下四级还没过）。首先简历就没过审何谈后面的笔试、面试，这也是我之前在智联上投的那么多，都杳无音信了。这里也吐槽下智联招聘不能自己上传自己的简历，而且企业水分太多了，但招聘的多、质量不高。<br><br>给大家推荐两个软件:</p><ul><li><p>拉勾网 这上面培训机构少大厂正规厂很多，都是质量高的招聘</p></li><li><p>看准网 这上面都是一些公司的消息，具体的公司信息、一些面试人的经验，前员工、在职员工的评价等消息（当然也要去辩证的看这些信息，大部分都是求职的真实经历）。</p><p>说到简历我这里有一模板可以供大家参考下。<a href="https://download.csdn.net/download/makejiec/12231427" target="_blank" rel="noopener">简历模板</a></p></li></ul><p>说到写简历，大家还是要用心去做，别用搞那些花里胡哨的，没有用毕竟是做技术的谁看你的花里胡哨的东西，主要的就是<u>个人信息</u>、<u>求职意向</u>、<u>项目介绍</u>、还有就是个人技能、取得的证书（四级看起来没技术含量但在投简历是大家都能看到都是要求CET-4/6的），最后个人一些评价、爱好什么的都写几句话，不要太长了。<br><br>说到项目就是最重要的了，通常面试都是问你们这个是干嘛的，你负责干嘛的，这些都要弄清楚，里面用了哪些知识点等，所以简历里的项目要写清楚，项目的描述、项目负责的模块。要写上去，别一句话就带过了，写个50-100字。项目不要多，应届生没项目就毕业设计，加平时的做的，如果你参加过一些比赛那就最好了都写上，这里有人说简历超过一页，我感觉这不是关键，只要你项目多，哪怕五六页也是实力的象征（当然太多不太好），控制个一两页就行了，我刚开始投的也是花里胡哨的只有一页纸，项目什么没写清楚，疯狂写在学校的经历什么的，这些对投开发岗的同学来说真的是无一利，还有就是别有错别字，多检查大小写字母等比如Java就别写java，熟用的软件写全名大小写，就别直接写个vs了。这样一看就不是正规军。这里给也还给没项目的小伙伴一个建议：如果没有那就去github上面下几个，看源码，这些都是很好的资料，看的时候做好笔记，里面那些是知识点都要记下来，你也要看相关的博客看看别人面试时都问哪些东西。<br>简历过了就是笔试面试了，这就是考你实力，所以多复习下相关的知识，这里给你们建议一下。比如我投的嵌入式的相关的，你就去网上找找笔试题做，网上还是很全的百度文库就有，然后看你都的岗位要求，比如会Linux你就去了解下，什么基本的操作命令、gcc编程、gdb调试、makefile的编写都要了解下。你要是面试单片机开发的那就不用说什么8051、ARM单片机上课时没记住的知识点，那就要复习下了。还有就是一些协议什么串口、IIC、USB了解一两个，可能面试会问，不用太精通，像串口有几条线，编程时你要怎么配置串口啊，这些还是要搞清楚的，不说会做起码要知道。再比如你要是网络编程方面，你要懂tcp/ip协议，tcp的三次握手、四次挥手，这些都是必问的知识点，操作系统方面就要弄清楚更多了，什么进程、线程、进程间的通信（IPC）、锁，总之操作系统方面要好好准备，多看书资料，工资高意味着压力也大。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上都是我自己的经历，每个人都有不同的情况，但还是希望能给大家一个好的启发。总之要自信，广投简历，机会是自己找的，多少付出就会有多少收获，也要多学学知识了，再好的岗位没有实力也不会要你。为什么别人好几份offer你却没有，有人说好找工作容易，有人说难。这些都是没用心去做，不管我们以后做什么总之用心去干，总会有收获的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试的酸甜苦辣&quot;&gt;&lt;a href=&quot;#面试的酸甜苦辣&quot; class=&quot;headerlink&quot; title=&quot;面试的酸甜苦辣&quot;&gt;&lt;/a&gt;面试的酸甜苦辣&lt;/h2&gt;&lt;p&gt;2020是一个充满无奈的年份，从疫情爆发后很多公司都取消春招了，然而每年应届毕业生都是再创新高。前几个月教育部发布的应届生人数达到了875万，这是多么恐怖的数字。即使研究生报名的人数多，再加上出国留学的几十万，还有今年的研究生扩招，但还有19届毕业生、那些二战三战的学生们。这该有多少人会面临就业压力。&lt;br&gt;&lt;br&gt;我自己在找工作时就发现了今年的工作不好找切身体会啊，先说说自己的面试经历吧&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://makejiec.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="面试" scheme="https://makejiec.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="经验" scheme="https://makejiec.gitee.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="感悟" scheme="https://makejiec.gitee.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>时间编程</title>
    <link href="https://makejiec.gitee.io/2020/03/04/20200304/"/>
    <id>https://makejiec.gitee.io/2020/03/04/20200304/</id>
    <published>2020-03-04T08:41:09.000Z</published>
    <updated>2020-03-10T08:55:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间编程"><a href="#时间编程" class="headerlink" title="时间编程"></a>时间编程</h2><h3 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h3><ul><li>UTC(世界标准时间)-也就格林威治时间（GMT）</li><li>CT(日历时间)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span>* tloc)  <span class="comment">//时间获取</span></span><br></pre></td></tr></table></figure></li></ul><meta name="referrer" content="no-referrer"><a id="more"></a><h3 id="时间转化"><a href="#时间转化" class="headerlink" title="时间转化"></a>时间转化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将日历时间转化为格林威治标准时间*/</span></span><br><span class="line"><span class="function">struct tm *<span class="title">gmtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span>* timep)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*将日历时间转化为本地时间，保存在TM结构中*/</span></span></span><br><span class="line"><span class="function">struct tm *<span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span>* timep)</span></span></span><br></pre></td></tr></table></figure><p>tm结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tm_sec;   <span class="comment">//秒值</span></span><br><span class="line">    <span class="keyword">int</span> tm_min;   <span class="comment">//分钟值</span></span><br><span class="line">    <span class="keyword">int</span> tm_hour;  <span class="comment">//小时值</span></span><br><span class="line">    <span class="keyword">int</span> tm_mday;  <span class="comment">//本月第几日</span></span><br><span class="line">    <span class="keyword">int</span> tm_mon;   <span class="comment">//本年第几月</span></span><br><span class="line">    <span class="keyword">int</span> tm_year;  <span class="comment">//tm_year+1900=哪一年</span></span><br><span class="line">    <span class="keyword">int</span> tm_wday;  <span class="comment">//本周第几日</span></span><br><span class="line">    <span class="keyword">int</span> tm_yday;  <span class="comment">//本年第几日</span></span><br><span class="line">    <span class="keyword">int</span> tm_isdst; <span class="comment">//日光节约时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="时间获取"><a href="#时间获取" class="headerlink" title="时间获取"></a>时间获取</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">local</span>;</span></span><br><span class="line">    <span class="keyword">time_t</span> t;</span><br><span class="line">    t=time(<span class="literal">NULL</span>);</span><br><span class="line">    local=localtime(&amp;t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Local hour is: %d\n"</span>,local-&gt;tm_hour);</span><br><span class="line">    local=gmtime(&amp;t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"UTC hour is: %d\n"</span>,local-&gt;tm_hour);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tvax4.sinaimg.cn/mw690/006p97Wqgy1gci0erfkxlj30oq05nmyk.jpg" alt="Linux_5"></p><h3 id="时间显示"><a href="#时间显示" class="headerlink" title="时间显示"></a>时间显示</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将tm格式的时间转化为字符串*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime</span><span class="params">(<span class="keyword">const</span> struct tm* tm)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*将日历时间转化为本地时间的字符串形式*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span>* timep)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">time_t</span> lt;</span><br><span class="line">    lt=time(<span class="literal">NULL</span>);</span><br><span class="line">    ptr=gmtime(&amp;lt);</span><br><span class="line">    <span class="built_in">printf</span>(asctime(ptr));</span><br><span class="line">    <span class="built_in">printf</span>(ctime(&amp;lt));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tvax2.sinaimg.cn/mw690/006p97Wqgy1gci0bt7i7sj30cf03oaan.jpg" alt="Linux_6"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*获取从今日凌晨到现在的时间差*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettinmeofday</span><span class="params">(struct timeval* tv,struct timezone* tz)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">struct timeval</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tv_sec;  <span class="comment">//秒数</span></span><br><span class="line">    <span class="keyword">int</span> tv_usec; <span class="comment">//微秒数</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*计算时间差值*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">            y++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tpstart</span>,<span class="title">tpend</span>;</span></span><br><span class="line">    <span class="keyword">float</span> timeuse;</span><br><span class="line">    </span><br><span class="line">    gettimeofday(&amp;tpstart,<span class="literal">NULL</span>); <span class="comment">//开始时间</span></span><br><span class="line">    function();</span><br><span class="line">    gettimeofday(&amp;tpend,<span class="literal">NULL</span>); <span class="comment">//结束时间</span></span><br><span class="line">    timeuse=<span class="number">1000000</span>*(tpend.tv_sec-tpstart.tv_sec)+tpend.tv_usec-tpstart.tv_usec;</span><br><span class="line">    timeuse/=<span class="number">1000000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Used Time: %f\n"</span>,timeuse);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tvax3.sinaimg.cn/mw690/006p97Wqgy1gci0d5erqgj30d702f0sx.jpg" alt="Linux_7"></p><h3 id="延时执行"><a href="#延时执行" class="headerlink" title="延时执行"></a>延时执行</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使程序睡眠seconds秒*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*使程序睡眠usec微秒*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> usec)</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;时间编程&quot;&gt;&lt;a href=&quot;#时间编程&quot; class=&quot;headerlink&quot; title=&quot;时间编程&quot;&gt;&lt;/a&gt;时间编程&lt;/h2&gt;&lt;h3 id=&quot;时间类型&quot;&gt;&lt;a href=&quot;#时间类型&quot; class=&quot;headerlink&quot; title=&quot;时间类型&quot;&gt;&lt;/a&gt;时间类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;UTC(世界标准时间)-也就格林威治时间（GMT）&lt;/li&gt;
&lt;li&gt;CT(日历时间)&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;time_t&lt;/span&gt; time(&lt;span class=&quot;keyword&quot;&gt;time_t&lt;/span&gt;* tloc)  &lt;span class=&quot;comment&quot;&gt;//时间获取&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
    
    </summary>
    
      <category term="Linux编程基础" scheme="https://makejiec.gitee.io/categories/Linux%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux" scheme="https://makejiec.gitee.io/tags/Linux/"/>
    
      <category term="时间编程" scheme="https://makejiec.gitee.io/tags/%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试</title>
    <link href="https://makejiec.gitee.io/2020/03/03/20200303/"/>
    <id>https://makejiec.gitee.io/2020/03/03/20200303/</id>
    <published>2020-03-03T03:33:03.000Z</published>
    <updated>2020-03-10T08:52:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h2><p>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c/c++程序员，gdb是必不可少的工具。</p><meta name="referrer" content="no-referrer"><a id="more"></a><p>GDB主要完成下面三个方面的功能：</p><ol><li>启动被调试</li><li>让被调试的程序在指定的位置停住</li><li>当程序被停止时，可以检查程序状态（如变量值）。</li></ol><h3 id="GDB调试步骤"><a href="#GDB调试步骤" class="headerlink" title="GDB调试步骤"></a>GDB调试步骤</h3><ol><li>编译生成可执行的文件<br>gcc -g test.c -o test</li><li>启动GDB<br>gdb test</li><li>在main函数处设置断点<br>break main</li><li>运行程序<br>run<br>启动GDB</li><li>gdb 程序名</li><li>gdb<br>file 程序名</li></ol><h3 id="常见的GDB命令"><a href="#常见的GDB命令" class="headerlink" title="常见的GDB命令"></a>常见的GDB命令</h3><ol><li><p>运行命令<br>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。<br>continue （简写c ）：继续执行，到下一个断点处（或运行结束）<br>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。<br>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的<br>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。<br>until+行号： 运行至某行，不仅仅用来跳出循环<br>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。<br>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)<br>quit：简记为 q ，退出gdb</p></li><li><p>设置断点<br>break(b)  行号：:在第n行处设置断点<br>break(b)  文件名:行号：在指定文件的指定行添加断点<br>break(b) 行号 if a＞b：当条件为真时，指定行处断点生效<br>break 函数名：在函数的入口处设置断点<br>delete 断点号n：删除第n个断点<br>disable 断点号n：暂停第n个断点<br>enable 断点号n：开启第n个断点<br>clear 行号n：清除第n行的断点<br>info b （info breakpoints） ：显示当前程序的断点设置情况<br>delete breakpoints：清除所有断点：</p></li><li><p>查看源码<br>list(l) ：其作用就是列出程序的源代码，默认每次显示10行。<br>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12<br>list 函数名：将显示“函数名”所在函数的源代码，如：list main<br>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</p></li><li><p>打印表达式<br>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。<br>print a：将显示整数 a 的值<br>print ++a：将把 a 中的值加1,并显示出来<br>print name：将显示字符串 name 的值<br>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数<br>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数<br>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a<br>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a<br>whatis ：查询变量或函数<br>info function： 查询函数<br>扩展info locals： 显示当前堆栈页的所有变量</p></li><li><p>查看运行信息<br>where/bt ：当前运行的堆栈列表；<br>bt backtrace 显示当前调用堆栈<br>up/down 改变堆栈显示的深度<br>set args 参数:指定运行时的参数<br>show args：查看设置好的参数<br>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</p></li><li><p>分割窗口<br>layout：用于分割窗口，可以一边查看代码，一边测试：<br>layout src：显示源代码窗口<br>layout asm：显示反汇编窗口<br>layout regs：显示源代码/反汇编和CPU寄存器窗口<br>layout split：显示源代码和反汇编窗口<br>Ctrl + L：刷新窗口</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GDB调试&quot;&gt;&lt;a href=&quot;#GDB调试&quot; class=&quot;headerlink&quot; title=&quot;GDB调试&quot;&gt;&lt;/a&gt;GDB调试&lt;/h2&gt;&lt;p&gt;GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c/c++程序员，gdb是必不可少的工具。&lt;/p&gt;
&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
    
    </summary>
    
      <category term="Linux编程基础" scheme="https://makejiec.gitee.io/categories/Linux%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux" scheme="https://makejiec.gitee.io/tags/Linux/"/>
    
      <category term="Gcc" scheme="https://makejiec.gitee.io/tags/Gcc/"/>
    
      <category term="GDB" scheme="https://makejiec.gitee.io/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件编程——系统调用</title>
    <link href="https://makejiec.gitee.io/2020/02/26/20200226/"/>
    <id>https://makejiec.gitee.io/2020/02/26/20200226/</id>
    <published>2020-02-26T14:53:39.000Z</published>
    <updated>2020-03-10T08:45:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux系统调用——文件访问"><a href="#Linux系统调用——文件访问" class="headerlink" title="Linux系统调用——文件访问"></a>Linux系统调用——文件访问</h2><p>Linux中的文件编程可以使用两种方法：</p><ul><li>Linux的系统调用</li><li>C语言库函数</li></ul><p>前者依赖与Linux系统，后者与操作系统无关。</p><a id="more"></a><meta name="referrer" content="no-referrer"><h3 id="系统调用——创建"><a href="#系统调用——创建" class="headerlink" title="系统调用——创建"></a>系统调用——创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filname, <span class="keyword">mode_t</span> mode)</span></span></span><br></pre></td></tr></table></figure><p>mode:<br>   S_IRUSER  可读  -&gt;  1 <br>   S_IWUSER  可写  -&gt;  2<br>   S_IXUSER  可执行 -&gt;  4<br>   S_IRWXU   可读、写、执行 -&gt; 7</p><p>int main(int argc,char *argv[])<br><br>其中argc：参数的个数<br>   argv：保存的参数的值</p><p>rwx-&gt;124<br><br>数字rwxrwrwx表示：文件所有者 文件所有者所在的组 其他用户</p><ul><li>file_creat.c： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_file</span><span class="params">(<span class="keyword">char</span> *filename)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建的文件所具有的属性*/</span></span><br><span class="line"><span class="keyword">if</span>(creat(filename,<span class="number">0755</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"creat file %s failure!\n"</span>,filename);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"creat file %s success!\n"</span>,filename);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">perror(<span class="string">"you have't input the filename,please try again!\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;argc; i++)&#123;</span><br><span class="line">create_file(argv[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://tva1.sinaimg.cn/large/006p97Wqgy1gca7mvcezuj30rb066mzs.jpg" alt="Linux_1"></p><h2 id="文件描述"><a href="#文件描述" class="headerlink" title="文件描述"></a>文件描述</h2><p>在Linux中，所有打开的文件都对应一个<font color="red">文件描述符</font>。文件描述符是一个非负整数。当打开一个文件时，系统就分配一个整数。范围是0 - OPEN_MAX,现在可以允许每个进程同时打开1024个文件。</p><h3 id="系统调用——打开"><a href="#系统调用——打开" class="headerlink" title="系统调用——打开"></a>系统调用——打开</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">／*<span class="number">0</span>打开函数*／</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">int</span> flags)</span> </span></span><br><span class="line">int open(const char *pathname,int flags, mode_t mode) flag里面包含O_CREAT</span><br></pre></td></tr></table></figure><p>flags:打开标志<br>O_RDONLY　　　只读<br>O_WRONLY　　　只写<br>O_RDWR　　　　读写<br>O_APPEND　　　追加<br>O_CREAT　　　　创建<br>O_NOBLOCK　　非阻塞<br></p><p>如果使用了Ｏ_CREATE标志，则使用的函数是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>如果文件中没有此文件就自动创建一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">int fd;</span><br><span class="line">if(argc&lt;2)&#123;</span><br><span class="line"></span><br><span class="line">puts(&quot;please input the open file pathname!\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">if((fd=open(argv[1],O_CREAT|O_RDWR,0755))&lt;0)&#123;</span><br><span class="line"></span><br><span class="line">perror(&quot;open file failure!\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printf(&quot;open file %s success!\n&quot;,fd);</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统调用——关闭系统"><a href="#系统调用——关闭系统" class="headerlink" title="系统调用——关闭系统"></a>系统调用——关闭系统</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br></pre></td></tr></table></figure><h3 id="系统调用——读"><a href="#系统调用——读" class="headerlink" title="系统调用——读"></a>系统调用——读</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *buf,<span class="keyword">size_t</span> length)</span></span></span><br></pre></td></tr></table></figure><p>从文件描述符fd所指定的文件中读取length个字节到buf所指向的缓冲区中返回值为读取的字节数</p><h3 id="系统调用——写"><a href="#系统调用——写" class="headerlink" title="系统调用——写"></a>系统调用——写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *buf,<span class="keyword">size_t</span> length)</span></span></span><br></pre></td></tr></table></figure><p>把length个字节从buf指向的缓冲区中写到文件描述符fd所指向的文件中，返回值为写入的字节数</p><h3 id="系统调用——定位"><a href="#系统调用——定位" class="headerlink" title="系统调用——定位"></a>系统调用——定位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">offset_t</span> offset, <span class="keyword">int</span> whence)</span></span></span><br></pre></td></tr></table></figure><p>offset可取负值，表示向前移动<br>将文件读写指针相对whence移动offset个字节。成功时，返回文件指针相对于文件头的位置。<br><br>whence:<br>SEEK_SET：相对文件开头<br>SEEK_CUR：相对文件读写指针的当前位置<br>SEEK_END：相对文件末尾</p><p>计算文件长度:<br></p><p><code>lseek(fd, 0, SEEK_END)</code></p><h3 id="系统调用——访问判断"><a href="#系统调用——访问判断" class="headerlink" title="系统调用——访问判断"></a>系统调用——访问判断</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">int</span> mode)</span></span></span><br></pre></td></tr></table></figure><p>mode:R_OK, W_OK, X_OK, F_OK(文件存在)<br><br>成功，返回为0。失败返回-1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(access(<span class="string">"/etc/passwd"</span>,R_OK)==<span class="number">0</span>) <span class="comment">//判断文件passwd是否可读</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"/etc/passwd can be read!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统调用——文件的读写-复制"><a href="#系统调用——文件的读写-复制" class="headerlink" title="系统调用——文件的读写(复制)"></a>系统调用——文件的读写(复制)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; fcntl.h&gt;   //for open</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; unistd.h&gt;  //for close</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> from_fd,to_fd;</span><br><span class="line">    <span class="keyword">int</span> bytes_read,bytes_write;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Usage: %s fromfile tofile/n/a"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*打开源文件*/</span></span><br><span class="line">    <span class="keyword">if</span>((from_fd=open(argv[<span class="number">1</span>],O_RDONLY))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Open %s Error:%s/n"</span>,argv[<span class="number">1</span>],strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*创建目的文件*/</span></span><br><span class="line">    <span class="keyword">if</span>((to_fd=open(argv[<span class="number">2</span>],O_WRONLY|O_CREAT,S_IRUSR|S_IWUSR))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Open %s Error:%s/n"</span>,argv[<span class="number">2</span>],strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*拷贝文件*/</span></span><br><span class="line">    <span class="keyword">while</span>(bytes_read=read(from_fd,buffer,BUFFER_SIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((bytes_read==<span class="number">-1</span>)&amp;&amp;(errno!=EINTR)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bytes_read&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr=buffer;</span><br><span class="line">            <span class="keyword">while</span>(bytes_write=write(to_fd,ptr,bytes_read))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((bytes_write==<span class="number">-1</span>)&amp;&amp;(errno!=EINTR)) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(bytes_write==bytes_read) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(bytes_write&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ptr+=bytes_write;</span><br><span class="line">                    bytes_read-=bytes_write;                    </span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bytes_write==<span class="number">-1</span>) <span class="keyword">break</span>;           </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    close(from_fd);</span><br><span class="line">    close(to_fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006p97Wqgy1gchxqbjupnj30ua0fjq5j.jpg" alt="Linux_2"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux系统调用——文件访问&quot;&gt;&lt;a href=&quot;#Linux系统调用——文件访问&quot; class=&quot;headerlink&quot; title=&quot;Linux系统调用——文件访问&quot;&gt;&lt;/a&gt;Linux系统调用——文件访问&lt;/h2&gt;&lt;p&gt;Linux中的文件编程可以使用两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux的系统调用&lt;/li&gt;
&lt;li&gt;C语言库函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前者依赖与Linux系统，后者与操作系统无关。&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式Linux" scheme="https://makejiec.gitee.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
    
      <category term="Linux" scheme="https://makejiec.gitee.io/tags/Linux/"/>
    
      <category term="文件" scheme="https://makejiec.gitee.io/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="系统调用" scheme="https://makejiec.gitee.io/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件编程——库函数</title>
    <link href="https://makejiec.gitee.io/2020/02/25/20200225/"/>
    <id>https://makejiec.gitee.io/2020/02/25/20200225/</id>
    <published>2020-02-25T13:43:15.000Z</published>
    <updated>2020-03-10T08:47:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="库函数——文件访问"><a href="#库函数——文件访问" class="headerlink" title="库函数——文件访问"></a>库函数——文件访问</h2><meta name="referrer" content="no-referrer">首先C库函数的的文件操作是独立与具体的操作系统的、与操作系统无关。<a id="more"></a><h3 id="库函数——创建与打开"><a href="#库函数——创建与打开" class="headerlink" title="库函数——创建与打开"></a>库函数——创建与打开</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span></span><br></pre></td></tr></table></figure><p>mode:<br>r,rb 只读<br>w,wb 只写，如果文件不存在，则创建该文件<br>a,ab 追加，如果文件不存在，则创建该文件<br>r+,r+b,rb+ 读写<br>w+,w+b,wh+ 读写，如果文件不存在，则创建该文件<br>a+,a+b,ab+ 读和追加，如果文件不存在，则创建该文件<br>b表示用于区分二进制和文件文本，Linux中不区分。</p><h3 id="库函数——读"><a href="#库函数——读" class="headerlink" title="库函数——读"></a>库函数——读</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr,<span class="keyword">size_t</span>,<span class="keyword">size_t</span> n,FILE stream)</span><br></pre></td></tr></table></figure><p>从stream指向的文件中读取n个字段，每个字段为size个自己，并将读取的数据放入ptr所致的字符数组中，返回实际一度去的字节数。</p><h3 id="库函数——写"><a href="#库函数——写" class="headerlink" title="库函数——写"></a>库函数——写</h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span>* ptr,<span class="keyword">size_t</span> size,<span class="keyword">size_t</span> n,FILE* stream)</span><br></pre></td></tr></table></figure><p> 从缓冲区ptr所指的数组中把n个字段写到stream指向的文件中，每个字段长为size个字节，返回实际写入的字段数。</p><h3 id="库函数——读、写字符"><a href="#库函数——读、写字符" class="headerlink" title="库函数——读、写字符"></a>库函数——读、写字符</h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE* stream)</span> <span class="comment">//从指定文件中读一个字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fput</span><span class="params">(<span class="keyword">int</span> c,FILE* stream)</span> <span class="comment">//向指定的文件中写入一个字符</span></span></span><br></pre></td></tr></table></figure><p> 从指定文件读取字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="comment">/*“rt”：只读打开一个文本文件，只允许读数据</span></span><br><span class="line"><span class="comment">　　  “wt”：只写打开或建立一个文本文件，只允许写数据 */</span></span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">"c1.txt"</span>,<span class="string">"rt"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nCannot open file strike key exit!"</span>);</span><br><span class="line">        getch();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ch=fgetc(fp);</span><br><span class="line">    <span class="keyword">while</span>(ch!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(ch)</span><br><span class="line">        ch=fget(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tvax3.sinaimg.cn/large/006p97Wqgy1gchyhvyc6gj30gx07kgmm.jpg" alt="Linux_3"></p><p>向指定文件中写入字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="comment">/*“rt”：只读打开一个文本文件，只允许读数据</span></span><br><span class="line"><span class="comment">　　  “wt”：只写打开或建立一个文本文件，只允许写数据 */</span></span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">"string"</span>,<span class="string">"wt+"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nCannot open file strike key exit!"</span>);</span><br><span class="line">        <span class="comment">//getch();</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"input a string:\n"</span>);</span><br><span class="line">    ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch!=<span class="string">'\n'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fputc(ch,fp);</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tvax2.sinaimg.cn/large/006p97Wqgy1gchypjjfg8j30ka096jsn.jpg" alt="Linux_4"></p><h3 id="库函数——格式化读"><a href="#库函数——格式化读" class="headerlink" title="库函数——格式化读"></a>库函数——格式化读</h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fscanf</span>(FILE* stream, <span class="keyword">char</span>* fomat[,argument...]) <span class="comment">//从一个流这种进行格式化输入</span></span><br></pre></td></tr></table></figure><h3 id="库函数——格式化写"><a href="#库函数——格式化写" class="headerlink" title="库函数——格式化写"></a>库函数——格式化写</h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE* stream,<span class="keyword">char</span>* fomat[,argument...])</span> <span class="comment">//格式化输出到一个流中</span></span></span><br></pre></td></tr></table></figure><h3 id="库函数-定位"><a href="#库函数-定位" class="headerlink" title="库函数-定位"></a>库函数-定位</h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE* stream,<span class="keyword">long</span> offset,<span class="keyword">int</span> whence)</span></span></span><br></pre></td></tr></table></figure><p> whence:<br>SEEK_SET 文件头开始<br>SEEK_CUR 当前位置开始<br>SEEK_END 文件结束开始<br></p><h3 id="路径获取"><a href="#路径获取" class="headerlink" title="路径获取"></a>路径获取</h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getcwd</span><span class="params">(<span class="keyword">char</span>* buffer,<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure><p>把获取的路径拷贝到buffer中,如果buffer太小就会返回-1。</p><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt; sys/stat&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">char</span>* dir,<span class="keyword">int</span> mode)</span></span></span><br></pre></td></tr></table></figure><p>成功，返回0，失败返回-1。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;库函数——文件访问&quot;&gt;&lt;a href=&quot;#库函数——文件访问&quot; class=&quot;headerlink&quot; title=&quot;库函数——文件访问&quot;&gt;&lt;/a&gt;库函数——文件访问&lt;/h2&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
首先C库函数的的文件操作是独立与具体的操作系统的、与操作系统无关。
    
    </summary>
    
      <category term="嵌入式Linux" scheme="https://makejiec.gitee.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
    
      <category term="Linux" scheme="https://makejiec.gitee.io/tags/Linux/"/>
    
      <category term="库函数" scheme="https://makejiec.gitee.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    
      <category term="文件" scheme="https://makejiec.gitee.io/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Makefile工程管理</title>
    <link href="https://makejiec.gitee.io/2020/02/24/20200224-2/"/>
    <id>https://makejiec.gitee.io/2020/02/24/20200224-2/</id>
    <published>2020-02-24T09:09:57.000Z</published>
    <updated>2020-03-10T08:49:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Makefile工程管理"><a href="#Makefile工程管理" class="headerlink" title="Makefile工程管理"></a>Makefile工程管理</h2><p>当我们写完一个c程序就会用gcc去编译、连接等操作。对于小的程序还可以，但在Linux内核中有上万的代码源文件，对每一个c文件编译、连接弄完不知道何年马月。所以GNU的make管理就会对整个软件工程对整个代码完成编译、连接。</p><a id="more"></a><meta name="referrer" content="no-referrer">make在执行时，有一个命名为Makefile的文件，Makefile文件中描述了整个工程的编译，连接等规则。包括：工程中哪些源文件性需要编译以及如何编译；需要创建那些库文件以及如何创建这些这些库文件、如何产生我们想要的可执行文件。<h3 id="Makefile的规则"><a href="#Makefile的规则" class="headerlink" title="Makefile的规则"></a>Makefile的规则</h3><p>targets:prerequistes<br>　　　command<br><br>目标 依赖 命令<br>例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">    gcc -c main.c</span><br></pre></td></tr></table></figure><p>main.o就是目标；<br>main.c是依赖；<br>gcc -c main.c是命令</p><h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><p>make默认在当前目录寻找makefile或者Makefile工程文件，当名字不是这两者时，用如下命令：<br>make -f 文件名</p><h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>makefile中把那些没有依赖只有执行的动作的目标称为“伪目标”（phony targets）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f hello main.o func_1.o func_2.o</span><br></pre></td></tr></table></figure><p>“.PHONY”将“clean”目标声明为伪目标</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>例如：给上面的例子添加一个fun_3.o的依赖</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:main.o fun_1.o fun_2.o</span></span><br><span class="line">    gcc main.o fun_1.o fun_2.o -o hello</span><br></pre></td></tr></table></figure><p>第一种：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:main.o fun_1.o fun_2.o fun_3.o</span></span><br><span class="line">    gcc main.o fun_1.o fun_2.o fun_3.o -o hello</span><br></pre></td></tr></table></figure><p>第二种设置变量:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj=main.o fun_1.o fun_2.o fun_3.o </span><br><span class="line"><span class="section">hello:<span class="variable">$(obj)</span></span></span><br><span class="line">    gcc <span class="variable">$(obj)</span> -o hello</span><br></pre></td></tr></table></figure><p>在makefile中，存在系统默认的自动化变量</p><ul><li>$^：代表所有的依赖文件</li><li>$@：代表目标</li><li>$&lt;：代表第一个依赖文件</li></ul><p>例如:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:main.o fun_1.o fun_2.o</span></span><br><span class="line">    gcc main.o fun_1.o fun_2.o -o hello</span><br></pre></td></tr></table></figure><p>=&gt;</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:main.o fun_1.o fun_2.o</span></span><br><span class="line">    gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>makefile中“#”字符后面的内容被视作注释</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:main.o fun_1.o fun_2.o</span></span><br><span class="line">    @gcc main.o fun_1.o fun_2.o -o hello</span><br></pre></td></tr></table></figure><p>@：取消回显</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Makefile工程管理&quot;&gt;&lt;a href=&quot;#Makefile工程管理&quot; class=&quot;headerlink&quot; title=&quot;Makefile工程管理&quot;&gt;&lt;/a&gt;Makefile工程管理&lt;/h2&gt;&lt;p&gt;当我们写完一个c程序就会用gcc去编译、连接等操作。对于小的程序还可以，但在Linux内核中有上万的代码源文件，对每一个c文件编译、连接弄完不知道何年马月。所以GNU的make管理就会对整个软件工程对整个代码完成编译、连接。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux编程基础" scheme="https://makejiec.gitee.io/categories/Linux%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux" scheme="https://makejiec.gitee.io/tags/Linux/"/>
    
      <category term="makefile" scheme="https://makejiec.gitee.io/tags/makefile/"/>
    
      <category term="编程基础" scheme="https://makejiec.gitee.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>GCC程序编译</title>
    <link href="https://makejiec.gitee.io/2020/02/24/20200224-1/"/>
    <id>https://makejiec.gitee.io/2020/02/24/20200224-1/</id>
    <published>2020-02-24T09:09:45.000Z</published>
    <updated>2020-03-10T08:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCC程序编译"><a href="#GCC程序编译" class="headerlink" title="GCC程序编译"></a>GCC程序编译</h2><p>Linux系统下的gcc(GNU C Compiler)是GNU推出的功能强大、性能优越的多平台编译器，它的执行效率比一般编译器要高20%~30%</p><meta name="referrer" content="no-referrer"><a id="more"></a><p>GCC编译程序时，编译过程只可以被细分为四个阶段：<u><strong>预处理</strong></u>、<u>编译</u>、<u>汇编</u>、<u>链接</u></p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>Gcc通过后缀来区别输入文件的类别：</p><ul><li>.c：源代码文件</li><li>.a：由目标文件构成的库文件</li><li>.C,.cc,.cxx：c++源码文件</li><li>.h：头文件</li><li>.i：已处理过的c源代码文件</li><li>.ii：已预处理过的c++源文件</li><li>.o：编译后的目标文件</li><li>.s：汇编语言源代码文件</li><li>.S：经过预编译的汇编语言源代码文件</li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>基本用法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc [options] [filenames]</span><br></pre></td></tr></table></figure><p>编译选项</p><ul><li>-o output_filename：确定可执行文件的名称，如果没有gcc就给出预设的可执行a.out</li><li>-c：只编译，不链接为可执行文件生成.o为后缀的目标文件</li><li>-g：产生调试工具（GNU的gdb）所必要的符号信息，主要是调试用的命令</li><li>-O：对程序进行优化编译、链接，在编译、链接过程中进行优化处理，这样产生的可执行文件执行效率可以提高，但是速度会慢。</li><li>O2：比-O更好的优化，但是速度会更慢</li><li>-Idirname：将dirname所指的目录加入程序头文件目录中</li><li>Lname：在链接时，装载”libname.a”的函数库，如gcc foo.c -L/home/lib -lfoo -o foo</li><li>-static：静态链接，gcc -static hello.c -o hello</li></ul><p>静态链接和动态链接<br>使用静态库时，连接器找出程序所需的函数，然后将它们拷贝到可执行文件，一旦连接成功，静态程序库也就不再需要了。然而，在动态库中，动态库会在执行程序内留下一个标志指明当程序执行时，首先必须载入这个库，从而节省空间。一般在linux中默认都是动态库。</p><ul><li>-Wall：生成所有警告信息</li><li>-w：不生成任何警告信息</li><li>DWACRO：定义MACRO宏，等效于在程序中使用#define MACRO</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GCC程序编译&quot;&gt;&lt;a href=&quot;#GCC程序编译&quot; class=&quot;headerlink&quot; title=&quot;GCC程序编译&quot;&gt;&lt;/a&gt;GCC程序编译&lt;/h2&gt;&lt;p&gt;Linux系统下的gcc(GNU C Compiler)是GNU推出的功能强大、性能优越的多平台编译器，它的执行效率比一般编译器要高20%~30%&lt;/p&gt;
&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
    
    </summary>
    
      <category term="Linux编程基础" scheme="https://makejiec.gitee.io/categories/Linux%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux" scheme="https://makejiec.gitee.io/tags/Linux/"/>
    
      <category term="Gcc" scheme="https://makejiec.gitee.io/tags/Gcc/"/>
    
  </entry>
  
  <entry>
    <title>51单片机</title>
    <link href="https://makejiec.gitee.io/2019/12/30/20191230/"/>
    <id>https://makejiec.gitee.io/2019/12/30/20191230/</id>
    <published>2019-12-30T05:53:17.000Z</published>
    <updated>2021-01-02T14:09:41.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="51单片机-2"><a href="#51单片机-2" class="headerlink" title="51单片机(2)"></a>51单片机(2)</h2><meta name="referrer" content="never">每天学习一点单片机，先从51开始，边听郭天祥的视频，边看是自学发现还可以。<a id="more"></a><h3 id="由于图片可能显示不出来看博客https-blog-csdn-net-makejiec-article-details-103774296"><a href="#由于图片可能显示不出来看博客https-blog-csdn-net-makejiec-article-details-103774296" class="headerlink" title="由于图片可能显示不出来看博客https://blog.csdn.net/makejiec/article/details/103774296"></a>由于图片可能显示不出来看博客<a href="https://blog.csdn.net/makejiec/article/details/103774296" target="_blank" rel="noopener">https://blog.csdn.net/makejiec/article/details/103774296</a></h3><p>昨天，只是熟悉下c51编程的基础，像我学了好几年的c语言就只用看看与标准c差别就行了，其实差别不是很大，会c语言的一些简单的语法完全够了。<br>由于没有板子，这里则是基于keil μVision5+Proteus模拟调试的</p><ul><li>首先装好这另两个软件，在前面已经提供了<a href="http://www.91change.club/2019/12/29/c51-1/#more" target="_blank" rel="noopener"><font color="red" size="5">链接</font></a> <br><br><a href="https://mp.weixin.qq.com/s/T7A7xFRKTglRHZVKLtm4EA" target="_blank" rel="noopener"><font color="green" size="5">keil μVision5an安装教程</font></a>　　　　　<a href="https://mp.weixin.qq.com/s/3C_NZw7CJ_7SmAqtBIOv9Q" target="_blank" rel="noopener"><font color="green" size="5">Proteus安装教程</font></a><br><br><font color="red" size="4">这里Proteus在后面画图是总是出现闪退</font></li><li><strong>解决方法</strong>：<br><br>找到下面的文件 将他们全部复制到</li></ul><p><img src="https://tva1.sinaimg.cn/large/006p97Wqgy1gc7l6pvuo8j30qr0dgjz1.jpg" alt="c1"></p><p> 将他们全部复制到<font color="red" size="5">C:\ProgramData\Labcenter Electronics\Proteus 8 Professional\MODELS</font>下</p><p><img src="https://tvax3.sinaimg.cn/large/006p97Wqgy1gc7l98kix4j30s50fs7er.jpg" alt="c2"></p><p>替换已存在的文件，闪退就可以解决来了。<br></p><ul><li>安装完成<br></li></ul><p><img src="https://tva4.sinaimg.cn/large/006p97Wqgy1gc7la1g7f7j308c04ft90.jpg" alt="c3"></p><h4 id="下面就开始写第一个单片机程序"><a href="#下面就开始写第一个单片机程序" class="headerlink" title="下面就开始写第一个单片机程序"></a>下面就开始写第一个单片机程序</h4><ul><li><h3>新建工程</h3></li></ul><p><img src="https://tvax4.sinaimg.cn/large/006p97Wqgy1gc7laeudpzj30o909t41i.jpg" alt="c4"></p><p><img src="https://tvax1.sinaimg.cn/large/006p97Wqgy1gc7lau1hjij30lq0gbn2g.jpg" alt="c5"></p><ul><li><h3>新建一个文件，并把它添加到工程中</h3>Ctrl+N新建一个文件，并且保存为.c的后缀</li></ul><p><img src="https://tva1.sinaimg.cn/large/006p97Wqgy1gc7lb4qw1sj30l00fj0ws.jpg" alt="c6"></p><p>选择刚才创建的test.c文件</p><p><img src="https://tvax2.sinaimg.cn/large/006p97Wqgy1gc7lbpbyl9j30jo0e8wik.jpg" alt="c7"></p><ul><li><h3> 可以写代码了 </h3></li></ul><p><img src="https://tva4.sinaimg.cn/large/006p97Wqgy1gc7lc1jinpj30vh0imjy2.jpg" alt="c8"></p><br><br>**我这里的代码是控制6个数码管的循环点亮**- <h3>使用Proteus仿真画电路图</h3><p><img src="https://tva1.sinaimg.cn/large/006p97Wqgy1gc7lcjyxwhj311o0kltno.jpg" alt="c9"></p><p><img src="https://tvax4.sinaimg.cn/large/006p97Wqgy1gc7lcvkl5qj30m40hltax.jpg" alt="c10"></p><br><br>**接着一路点击Next到finish**<p><img src="https://tva2.sinaimg.cn/large/006p97Wqgy1gc7ld5mb4tj316x0q7wty.jpg" alt="c11"></p><ul><li><h3>画出你的电路图</h3></li></ul><p><img src="https://tva2.sinaimg.cn/large/006p97Wqgy1gc7ldi1uuwj30x20k0wtj.jpg" alt="c12"></p><ul><li><h3>将代码编译生成十六进制文件导入原理图中</h3></li></ul><p><img src="https://tva2.sinaimg.cn/large/006p97Wqgy1gc7ldqvor6j30vr0nc47h.jpg" alt="c13"></p><p><img src="https://tva2.sinaimg.cn/large/006p97Wqgy1gc7le757fpj31360kv1d3.jpg" alt="c14"></p><ul><li><h3>运行效果</h3></li></ul><p><img src="https://tva1.sinaimg.cn/large/006p97Wqgy1gc7lej2oqfg30ws0j44qp.gif" alt></p><h1 id="上述代码如下："><a href="#上述代码如下：" class="headerlink" title="上述代码如下："></a>上述代码如下：</h1><pre><code>#include&lt;red52.h&gt;#define uint unsigned int #define uchar unsigned char sbit wei = P2^7;    //位选sbit duan = P2^6;   //段选uchar code table[]={0x3f, 0x06, 0x5b, 0x4f,                   /*0*/ /*1*/ /*2*/ /*3*/                    0x66, 0x6d, 0x7d, 0x07,                   /*4*/ /*5*/ /*6*/ /*7*/                    0x7f, 0x6f, 0x77, 0x7c,                   /*8*/ /*9*/ /*A*/ /*b*/                    0x39, 0x5e, 0x79, 0x71                   /*C*/ /*d*/ /*E*/ /*F*/};  //字符0~f table表uchar num;uchar i;void delay(uint z);int main(void){    uchar count = 0;    uchar flag = 0x01;      while(1)    {        wei = 1;        P0 = ~flag;        wei = 0;         for(num = 0; num &lt; 16; num++)        {            duan = 1;            P0 = table[num];            duan = 0;            delay(100);        }        flag = flag &lt;&lt; 1;        count++;        if(count &gt;= 6)        {            flag = 0x01;            count = 0;        }    }}void delay(uint z)  //延迟{    uint x, y;    for(x=z; x&gt;0; x--)        for(y=110; y&gt;0; y--);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;51单片机-2&quot;&gt;&lt;a href=&quot;#51单片机-2&quot; class=&quot;headerlink&quot; title=&quot;51单片机(2)&quot;&gt;&lt;/a&gt;51单片机(2)&lt;/h2&gt;&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;
每天学习一点单片机，先从51开始，边听郭天祥的视频，边看是自学发现还可以。
    
    </summary>
    
    
      <category term="51单片机" scheme="https://makejiec.gitee.io/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
      <category term="嵌入式" scheme="https://makejiec.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>51单片机</title>
    <link href="https://makejiec.gitee.io/2019/12/29/20191229/"/>
    <id>https://makejiec.gitee.io/2019/12/29/20191229/</id>
    <published>2019-12-29T07:08:53.000Z</published>
    <updated>2021-01-02T14:09:27.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="51单片机-一"><a href="#51单片机-一" class="headerlink" title="51单片机(一)"></a>51单片机(一)</h2><meta name="referrer" content="no-referrer"><p>51单片机虽然已经出现了30年，但在使用上还是很广泛，市场上也出现一大推以8051为核心的一批单片机系统</p><a id="more"></a><p>大三期间学过单片机，主要是用汇编代码写的51代码，最近的毕业设计选择的题目是基于51单片机开发，不过都是用C语言开发的。于是重新学习一下单片机：</p><p><font color="red" size="5">首先分享资料</font>：<a href="https://pan.baidu.com/s/1DmQB5Qf-F06jg8ZKjawS_w" target="_blank" rel="noopener">keil μvVision5链接 </a>提取码：<font color="green" size="5"> xgjx </font></p><p><a href="https://pan.baidu.com/s/1osu-R5T98ShACMxWbdm66w" target="_blank" rel="noopener">Proteusz仿真链接</a> 提取码: <font color="green" size="5"> 4ktm </font></p><h4 id="c51编译器支持的数据结构"><a href="#c51编译器支持的数据结构" class="headerlink" title="c51编译器支持的数据结构"></a>c51编译器支持的数据结构</h4><meta name="referrer" content="no-referrer"><p><img src="https://ws1.sinaimg.cn/large/006p97Wqgy1gadqd4viupj30gn0b274e.jpg" alt="bdc60b2eb6a43448ee6e5d887191fdd9.png"></p><h4 id="51单片机使用的c语言的存储器类型"><a href="#51单片机使用的c语言的存储器类型" class="headerlink" title="51单片机使用的c语言的存储器类型"></a>51单片机使用的c语言的存储器类型</h4><p><img src="https://ws1.sinaimg.cn/large/006p97Wqgy1gadqfkb6l9j30er06gmx5.jpg" alt="6466a0aa00167bce5417367ac2182bc4.png"></p><p>这里的编译器是keil公司开发的 keil Vision5的IDE<br>，如下：<br><img src="https://ws1.sinaimg.cn/large/006p97Wqgy1gadqzszn1gj313k0og42b.jpg" alt="QQ图片20191229180157.png"></p><p>作为初学者看书是很枯燥的最好是看视频，这里推荐郭天祥的视频，讲的很好<a href="https://www.bilibili.com/video/av61979588?p=1" target="_blank" rel="noopener">十天学会51单片机</a></p><p>最好买一块板子，看了下淘宝100左右，如果没有板子那只有proteus仿真了</p><p>安装过程就不用介绍了。</p><p>最后看了一下书 发现c51对ANSI c有一些差异在库函数上有一些差异，具体在c51提供的库函数文档里面都有，在写代码时应该看看<br><img src="https://ws1.sinaimg.cn/large/006p97Wqgy1gadt4sa5wfj30z30kxmym.jpg" alt="QQ图片20191229191557.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;51单片机-一&quot;&gt;&lt;a href=&quot;#51单片机-一&quot; class=&quot;headerlink&quot; title=&quot;51单片机(一)&quot;&gt;&lt;/a&gt;51单片机(一)&lt;/h2&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;51单片机虽然已经出现了30年，但在使用上还是很广泛，市场上也出现一大推以8051为核心的一批单片机系统&lt;/p&gt;
    
    </summary>
    
    
      <category term="51单片机" scheme="https://makejiec.gitee.io/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
      <category term="嵌入式" scheme="https://makejiec.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="https://makejiec.gitee.io/2019/11/21/20191121/"/>
    <id>https://makejiec.gitee.io/2019/11/21/20191121/</id>
    <published>2019-11-21T15:22:16.000Z</published>
    <updated>2021-01-02T13:14:08.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式匹配算法——KMP"><a href="#模式匹配算法——KMP" class="headerlink" title="模式匹配算法——KMP"></a>模式匹配算法——KMP</h2><meta name="referrer" content="no-referrer"><p>今天在看书数据结构关于模式匹配的算法看到一个改进的算法，想起了之前在力扣上一道算法题就研究了一番</p><a id="more"></a><p>不解释直接上代码：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">KMP算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="keyword">char</span> *T,<span class="keyword">int</span> *next)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">char</span> *T, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> next[<span class="number">10</span>];      <span class="comment">//next数组</span></span><br><span class="line"><span class="keyword">char</span> T[<span class="number">10</span>] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> S[<span class="number">20</span>] = <span class="string">"ccccccdabcefg"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//char S[LEN_1_SIZE];   // T[LEN_2_SIZE];</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*printf("输入主串长度：");</span></span><br><span class="line"><span class="comment">    scanf("%d",&amp;n);</span></span><br><span class="line"><span class="comment">    printf("输入主串：");</span></span><br><span class="line"><span class="comment">    fgets(S, n, stdin);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    printf("输入模式串长度：");</span></span><br><span class="line"><span class="comment">    scanf("%d",&amp;m);</span></span><br><span class="line"><span class="comment">    printf("输入模式串：");</span></span><br><span class="line"><span class="comment">    fgets(T, m, stdin);*/</span></span><br><span class="line"></span><br><span class="line">    get_next(T, next);</span><br><span class="line">    x = Index_KMP(S, T, pos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"在主串第%d处\n"</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"failed\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取next数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="keyword">char</span> *T,<span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>]=next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; (<span class="keyword">int</span>)<span class="built_in">strlen</span>(T))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span>|| T[i] == T[j])</span><br><span class="line">        &#123;</span><br><span class="line">            next[++i] = ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">char</span> *T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>, i = pos;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= (<span class="keyword">int</span>)<span class="built_in">strlen</span>(S) &amp;&amp; j &lt;= (<span class="keyword">int</span>)<span class="built_in">strlen</span>(T))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S[i] == T[j - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j &gt; (<span class="keyword">int</span>)<span class="built_in">strlen</span>(T)) </span><br><span class="line">        <span class="keyword">return</span> i - <span class="built_in">strlen</span>(T) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模式匹配算法——KMP&quot;&gt;&lt;a href=&quot;#模式匹配算法——KMP&quot; class=&quot;headerlink&quot; title=&quot;模式匹配算法——KMP&quot;&gt;&lt;/a&gt;模式匹配算法——KMP&lt;/h2&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;今天在看书数据结构关于模式匹配的算法看到一个改进的算法，想起了之前在力扣上一道算法题就研究了一番&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://makejiec.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://makejiec.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="模式匹配" scheme="https://makejiec.gitee.io/tags/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>经典排序算法</title>
    <link href="https://makejiec.gitee.io/2019/11/20/20191120-1/"/>
    <id>https://makejiec.gitee.io/2019/11/20/20191120-1/</id>
    <published>2019-11-20T14:33:55.000Z</published>
    <updated>2021-01-02T14:07:23.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经典排序算法"><a href="#经典排序算法" class="headerlink" title="经典排序算法"></a>经典排序算法</h2><meta name="referrer" content="no-referrer"><a id="more"></a><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">冒泡排序思想：从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。</span></span><br><span class="line"><span class="comment">算法的核心在于每次通过两两比较交换位置，选出剩余无序序列里最大（小）的数据元素放到队尾。冒泡排序的平均时间复杂度为O(n^2)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> num 6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,n;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">int</span> a[num];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; num - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                a[j] = a[j] + a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = a[j] - a[j+<span class="number">1</span>];</span><br><span class="line">                a[j] = a[j] - a[j+<span class="number">1</span>];</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>文档：归并排序.note<br>链接：<a href="http://note.youdao.com/noteshare?id=8342519d8cb88acfdb27d0290c25c3b9&amp;sub=65297D394CDF4BA5973652941437BEAC" target="_blank" rel="noopener">http://note.youdao.com/noteshare?id=8342519d8cb88acfdb27d0290c25c3b9&amp;sub=65297D394CDF4BA5973652941437BEAC</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">归并排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType s[], <span class="keyword">int</span> low, <span class="keyword">int</span> hight)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType s[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> hight)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Buff[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[NUM], low, hight, i, n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要排序的个数（小于20）："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    hight = n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    MergeSort(a, low, hight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType s[], <span class="keyword">int</span> low, <span class="keyword">int</span> hight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; hight)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + hight) / <span class="number">2</span>;</span><br><span class="line">        MergeSort(s, low, mid);</span><br><span class="line">        MergeSort(s, mid+<span class="number">1</span>, hight);</span><br><span class="line">        Merge(s, low, mid, hight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType s[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> hight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag, i ,j;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(flag = low; flag &lt;= hight; flag++)</span><br><span class="line">        Buff[flag] = s[flag];</span><br><span class="line">    <span class="keyword">for</span>(i = low, j = mid + <span class="number">1</span>, flag = i; i &lt;= mid &amp;&amp; j &lt;= hight; flag++)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(Buff[i] &lt;= Buff[j])</span><br><span class="line">            s[flag] = Buff[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s[flag] = Buff[j++];</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//s[flag] = Buff[i] &lt;= Buff[j] ? Buff[i++] : Buff[j++];</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &lt;= mid) </span><br><span class="line">        s[flag++] = Buff[i++];</span><br><span class="line">    <span class="keyword">if</span>(j &lt;= hight)</span><br><span class="line">        s[flag++] = Buff[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;经典排序算法&quot;&gt;&lt;a href=&quot;#经典排序算法&quot; class=&quot;headerlink&quot; title=&quot;经典排序算法&quot;&gt;&lt;/a&gt;经典排序算法&lt;/h2&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://makejiec.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://makejiec.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>经典排序算法</title>
    <link href="https://makejiec.gitee.io/2019/11/20/20191120-2/"/>
    <id>https://makejiec.gitee.io/2019/11/20/20191120-2/</id>
    <published>2019-11-20T13:11:03.000Z</published>
    <updated>2021-01-02T14:06:38.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经典排序算法"><a href="#经典排序算法" class="headerlink" title="经典排序算法"></a>经典排序算法</h2><meta name="referrer" content="no-referrer">通过一段时间的学习，总结了一些经典的排序算法：选择排序、快速排序、冒泡排序、归并排序。<p>文档：排序.note<br>链接：<a href="http://note.youdao.com/noteshare?id=b1cebe76a33cc5e7b8cd5c83c825e34e&amp;sub=96766F443A534C6688B05064DDAB5DE2" target="_blank" rel="noopener">http://note.youdao.com/noteshare?id=b1cebe76a33cc5e7b8cd5c83c825e34e&amp;sub=96766F443A534C6688B05064DDAB5DE2</a></p><a id="more"></a><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>废话不多说上代码：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">选择排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[NUM], i, j, n;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要排序的个数（小于20）："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            min = a[j] &lt; a[min] ? j : min;</span><br><span class="line">        <span class="keyword">if</span>(min != i)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] ^= a[min];</span><br><span class="line">            a[min] ^= a[i];</span><br><span class="line">            a[i] ^= a[min];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">快速排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType s[], <span class="keyword">int</span> low, <span class="keyword">int</span> hight)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(ElemType s[], <span class="keyword">int</span> low, <span class="keyword">int</span> hight)</span></span>;</span><br><span class="line"></span><br><span class="line">int main(void)`</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a[NUM], low, hight, i, n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要排序的个数（小于20）："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    hight = n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    QuickSort(a, low, hight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType s[], <span class="keyword">int</span> low, <span class="keyword">int</span> hight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; hight)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> piv = Partition(s, low, hight);</span><br><span class="line">        QuickSort(s, low, piv - <span class="number">1</span>);</span><br><span class="line">        QuickSort(s, piv+<span class="number">1</span>, hight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(ElemType s[], <span class="keyword">int</span> low, <span class="keyword">int</span> hight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pi = s[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; hight)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; hight &amp;&amp; s[hight] &gt;= pi)</span><br><span class="line">            --hight;</span><br><span class="line">        s[low] = s[hight];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; hight &amp;&amp; s[low] &lt;= pi)</span><br><span class="line">            ++low;</span><br><span class="line">        s[hight] = s[low];</span><br><span class="line">    &#125;</span><br><span class="line">    s[low] = pi;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;经典排序算法&quot;&gt;&lt;a href=&quot;#经典排序算法&quot; class=&quot;headerlink&quot; title=&quot;经典排序算法&quot;&gt;&lt;/a&gt;经典排序算法&lt;/h2&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
通过一段时间的学习，总结了一些经典的排序算法：选择排序、快速排序、冒泡排序、归并排序。

&lt;p&gt;文档：排序.note&lt;br&gt;链接：&lt;a href=&quot;http://note.youdao.com/noteshare?id=b1cebe76a33cc5e7b8cd5c83c825e34e&amp;amp;sub=96766F443A534C6688B05064DDAB5DE2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://note.youdao.com/noteshare?id=b1cebe76a33cc5e7b8cd5c83c825e34e&amp;amp;sub=96766F443A534C6688B05064DDAB5DE2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://makejiec.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://makejiec.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>中秋节开始堕落了</title>
    <link href="https://makejiec.gitee.io/2019/09/15/20190915/"/>
    <id>https://makejiec.gitee.io/2019/09/15/20190915/</id>
    <published>2019-09-15T07:19:13.000Z</published>
    <updated>2021-01-02T11:56:02.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中秋节快乐"><a href="#中秋节快乐" class="headerlink" title="中秋节快乐"></a>中秋节快乐</h2><meta name="referrer" content="no-referrer"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=32835565&auto=0&height=66"></iframe><br>最近的学习随着实习加中秋，已经好几天没有开始了，总感觉我要凉了。<a id="more"></a><p><img src="https://tva1.sinaimg.cn/large/006p97Wqgy1gc7k7afgemj31hc0zm40r.jpg" alt="月亮"></p><p>己亥中秋，我没有回家，同舍有两人赴苏州实习，只有我与另一名室友。但我们在寝室打了两天的游戏，我感到深深的罪恶感，我已经一个星期没看高数和英语，专业课也没怎么搞。</p><p>心想着休息几天，可是越休息越想放弃考研，或许我当初没和家人吹牛一定要考研我现在的日子一定会很好过的，每天写写代码，打打游戏，找找工作，接着每天就不用这么烦恼了，每天想着考研，但也想着没考上后的生活会怎样，二战？到明年秋招也结束了，工作也不好找。一大堆的痛苦的选择就会铺面而来，难顶啊。</p><p>还有几天实习也就结束了，也该回归到紧张状态了，毕竟现在离考研已经没有100天了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;中秋节快乐&quot;&gt;&lt;a href=&quot;#中秋节快乐&quot; class=&quot;headerlink&quot; title=&quot;中秋节快乐&quot;&gt;&lt;/a&gt;中秋节快乐&lt;/h2&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=32835565&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;
&lt;br&gt;
最近的学习随着实习加中秋，已经好几天没有开始了，总感觉我要凉了。
    
    </summary>
    
    
      <category term="随笔" scheme="https://makejiec.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="考研" scheme="https://makejiec.gitee.io/tags/%E8%80%83%E7%A0%94/"/>
    
      <category term="感悟" scheme="https://makejiec.gitee.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="中秋节" scheme="https://makejiec.gitee.io/tags/%E4%B8%AD%E7%A7%8B%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>浅谈c指针(二)</title>
    <link href="https://makejiec.gitee.io/2019/08/27/20190827/"/>
    <id>https://makejiec.gitee.io/2019/08/27/20190827/</id>
    <published>2019-08-27T08:33:00.000Z</published>
    <updated>2021-01-01T16:12:05.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅谈c语言灵魂——指针"><a href="#浅谈c语言灵魂——指针" class="headerlink" title="浅谈c语言灵魂——指针"></a>浅谈c语言灵魂——指针</h2><p>由于最近开学了，又要实习，还要准备考研，好几天没写了。</p><a id="more"></a><p>上次写到指针和数组，今天在看一些c的面试题发现一个很重要的东西就是<font size="5" color="red">const</font>了，相信学过c的人一定会说：“const就意味着是常数了”，那只能说明你只懂皮毛了，这里推荐一篇外国大佬 Dan Saks的文章《const T vs T const》，在他的文章里完全概括了所有的用法。</p><p>下面的代码什么意思：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  <span class="keyword">int</span>  a;</span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">const</span>  a;</span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">int</span>  *a;</span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">const</span>  *a;</span><br><span class="line"><span class="keyword">int</span>*  <span class="keyword">const</span>  a;</span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">const</span>*  <span class="keyword">const</span> a ;</span><br></pre></td></tr></table></figure><p>一般的int const和const int效果是一样的，a都是一个常数整数型的数，在这里我们只要记住<strong>int 与const 哪个放前哪个放后都是一样的</strong>，第三个a首先是一个指针其次它是一个指向常整数型的，也就是说*a是常量了，是不能被赋值的，但是a的值是可以改变的，也就是说它可以重新指向另一个地址。看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  i1 = <span class="number">30</span>; </span><br><span class="line"><span class="keyword">int</span>  i2 = <span class="number">40</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a = &amp;i1; </span><br><span class="line">a  =  &amp;i2;         <span class="comment">/* 注意这里，a可以在任意时候重新赋值一个新内存地址 */</span> </span><br><span class="line">i2  =  <span class="number">80</span>;           <span class="comment">/* 注意看：这里不能能用*a = 80 来代替 */</span> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *a); <span class="comment">/* 输出是 80 */</span></span><br></pre></td></tr></table></figure><p>首先const修饰的是整个<em>a(注意不是a)。所以</em>a是常量，不能被赋值的，即使a所指的i2是变量。</p><p>由于前面第一个和第二已经说明const和int谁在前都是一样的，所以第三个和第四个效果也是一样的，这里可能就会问了那怎么用const来修饰a呢？，注意第五个的const的位置，那你就应该明白了。</p><p><strong>int  *const  a</strong> (int*  const和int  *const是一样的，只是风格不同)<br><br>先看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 = <span class="number">30</span>; </span><br><span class="line"><span class="keyword">int</span> i2 = <span class="number">40</span>; </span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> a = &amp;i1; </span><br><span class="line"><span class="comment">/* a = &amp;i2; 注意这里，a 不能再这样重新赋值了，即不能再指向另一个新地址第4 行的注释）*/</span> </span><br><span class="line">i1 = <span class="number">80</span>;               <span class="comment">/* 想想看：这里能用 *a = 80; 来代替吗？可以，这里可以通过*a 修改 i1 的值。（第 5 行的注释）*/</span> </span><br><span class="line"><span class="comment">/* 请自行与前面一个例子比较。 */</span> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, *a);<span class="comment">/* 输出是 80 */</span></span><br></pre></td></tr></table></figure><p>写到这里相信你们都懂了，a的值是不能重新被赋值的。<strong>它只能永远指向初始化时的内存地址了</strong>但是你可以通过改变*a来修改i1的值了。</p><p>所以说第五个意思 a 是一个指向整型数的常指针（也就 是说，指针指向的整型数是可以修改的，但指针是不可修改的）</p><p>与前一个例子对照一下吧！看以下的两点分析：<br>1）a 因为有了 const 的修饰，所以只是一个指针常量：也就是说 a 值是不可修改的（即 a 不可以重新指向 i2 这个变量了）（请看第 4 行的注释）。<br>2）整个*a的前面没有 const 的修饰。也就是说，*a 是变量而不是常量，所以我们可以通过*a来修改它所指内存 i1 的值（请看第 5 行的注释）。<br><br><strong>总之一句话，这次的 a 是一个指向 int 变量类型数据的指针常量。</strong></p><p>也就是说如果 const 修饰在*a 前，则不能改的是*a(即不能类似这样：*a=50;赋值)而不是指 a。  如果 const 是直接写在 a前，则 a不能改(即不能类似这样：a=&i;赋值)。</p><p>说完第五个了，接着的int  const*  const  a; 最后一个意味着 a 是一个 指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可 修改的）</p><p>const的一些基本用法就这些了，最后补充一下：</p><pre><code>1：int  *pi 指针指向 const  int  i 常量的情况const  int  i1 = 40; int  *pi; pi  =  &amp;i1;     // 这样可以吗？不行，VC 下是编译错。                 // const  int 类型的 i1 的地址是不能赋值给指向 int 类型地址的指针 pi 的。否则 pi 岂不是能修改 i1 的值了吗！pi = (int *) &amp;i1;     //这样可以吗？强制类型转换可是 C 所支持的。//VC 下编译通过，但是仍不能通过 *pi = 80 来修改 i1 的值。去试试吧！看看具体的怎样。2：const  int  *pi 指针指向 const  int  i1 的情况const  int  i1=40; const  int  *pi; pi = &amp;i1;      // 两个类型相同，可以这样赋值。很显然，i1 的值无论是通过pi 还是 i1 都不能修改的。 </code></pre><p>什么还要如此看重关键字 const 呢？<br>1). 关键字 const 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数 为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃 圾，你就会很快学会感谢这点多余的信息。（当然，懂得用 const 的程序员很少会留下的垃圾 让别人来清理的。）<br>2). 通过给优化器一些附加的信息，使用关键字 const 也许能产生更紧凑的代码。<br>3). 合理地使用关键字 const 可以使编译器很自然地保护那些不希望被改变的参数，防止其 被无意的代码修改。简而言之，这样可以减少 bug 的出现。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;浅谈c语言灵魂——指针&quot;&gt;&lt;a href=&quot;#浅谈c语言灵魂——指针&quot; class=&quot;headerlink&quot; title=&quot;浅谈c语言灵魂——指针&quot;&gt;&lt;/a&gt;浅谈c语言灵魂——指针&lt;/h2&gt;&lt;p&gt;由于最近开学了，又要实习，还要准备考研，好几天没写了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指针" scheme="https://makejiec.gitee.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="c语言" scheme="https://makejiec.gitee.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
      <category term="const用法" scheme="https://makejiec.gitee.io/tags/const%E7%94%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2019年计划</title>
    <link href="https://makejiec.gitee.io/2019/08/24/20190824/"/>
    <id>https://makejiec.gitee.io/2019/08/24/20190824/</id>
    <published>2019-08-24T11:49:53.000Z</published>
    <updated>2021-01-02T13:29:46.822Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="密码：change" />    <label for="pass">密码：change</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19o9hYir0iovBFHJLnSh01mu1iR+JxeAQTSrkoqju+HxLhCRXlpcssBy64R/c2RuYQTir18SpNMNhAtYu9XWE6shEppCVFpLu2GrvZaxUxEQ9ihNX/W/OKFyMoiq+0XmhKJJ3dRGrwfy9kaoBrqCpErM6q+lxJxYncWgRp6bQIq7t4Epq3nDTwhFi4pliDNQw4Sqnn3pLDKuadl2UaOuFEPdoHQgGqnx1qGByyDUQz/2fBdfxo1nSfXgDi/yJOio+c6rfYRq08DxfcW1YE8aP9cP1PR+f/QR6dEp2LTPNCZpjBomlyInwnmMbvhONsySGz9kAcrhSFnK4hboYJRhKrwIFuwcxp91s+Mp4vC6jz2NlGgvYE8Lx3bfJIaiqi7T25gTp5kfb93hlYX+9bzCuE/aeddDFakXQZXYP7XdXrf9gxcb76sMyvj8yRxhBZ6E2u24+k9beaRDSYkzsYVPzYvTMIjqRrQ5L7rAh38AdWezLfXZF7YyOVzJM/rZywVTs0PwgAURDuqV8PT9J6/au39QSdxC3xauwL6oxGAUAkeiGN2oVU22e5YQurQ2jH4gxUoLnI1mH6+vo1GksX05l0mvTf6brrdh/k22BVoUesU/yAwKe0BpD0Kv+cDwV5+vad8IrjcQHWbuN0ojAC4kvz7eh2S0RSUZVOBOy6XKKd5JseuR4ZI32TzIbfm+tR8Xei5cgpV09KQ0b+aRkOgovUxbpLAIfcBUB6kBpDlUEw1i8k0hy2GwsSzOQ7r2Z/w/TusqLwxCJLHlzEJDe3ZLbou/4r2L/JdQ3tiv8WeQNFrTckR4Ytw1lpV7XL71qgjL9oFyLWfmbR4NjFcfqSP9gk7I/CogTQ/LSWj0QtNkLG9VW6Mt/3eN2MIZxTNB6tYhje5HKueEJhaZeyNm3zs4OTtxHLr7qgHHajbL7Bq8QdE1/uh3p4b7uJ3Nh9W3oMQrXue5PxXgBRZ9+U4fzLO2Mxd75sLMniXUIK9fUxH3uom3Oudh9Hyo0N4clYDBqXxmRZr+S0fo+o/OwTfI+UFbtTzUVBOluVpf9zi30iHXEO+HiHmZK7NFmrERGBJoFlS31FASPbx77S8AQUf9jXt3YuPrKS5Yfz7GHYQzQ1pnbqrTHg40cDzPeuE9BfwTV1z6yxMZF4qNXkP+TITD6pgNWBoBnRUNcQuGvs3SlUZFLuCI9mqv/jS6e3mZQ1Bb8Z66I0zC07B9NeFFpnyo5qqk2E+0e0723tnT2P9ocomkmPOtUS/bkMLur76lv4g6cJHSfWeSBwdM0VcLylA4XTPEjJjaqmQ9kHA00c5uHnhn17/YaBjtV0agt9A</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这是2019年对自己的一些要求，可能会实现其中一个，但是写出来才有动力，祝大家今天的计划都能实现，梦还是要有的，万一实现了呢，大家一起努力。
    
    </summary>
    
    
      <category term="flag" scheme="https://makejiec.gitee.io/tags/flag/"/>
    
      <category term="年度计划" scheme="https://makejiec.gitee.io/tags/%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>浅谈c指针(一)</title>
    <link href="https://makejiec.gitee.io/2019/08/21/20190821/"/>
    <id>https://makejiec.gitee.io/2019/08/21/20190821/</id>
    <published>2019-08-21T11:46:25.000Z</published>
    <updated>2020-02-24T08:35:33.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅谈c语言灵魂——指针"><a href="#浅谈c语言灵魂——指针" class="headerlink" title="浅谈c语言灵魂——指针"></a>浅谈c语言灵魂——指针</h2><meta name="referrer" content="no-referrer"><p>c语言什么最难，当然是指针(Pointer)，c语言之所以强大，以及其自由性，很大部分体现在其灵活的指针运用上。因此，说指针是c语言的灵魂，一点都不为过。</p><a id="more"></a><p>学c语言不学指针，那就等于没学。但是指针又是最难学的，指来指去连自己都指晕了，这也是为什么很对人放弃c语言的原因。</p><h3 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h3><h5 id="首先想一下下面这段代码的1、2输出是什么？"><a href="#首先想一下下面这段代码的1、2输出是什么？" class="headerlink" title="首先想一下下面这段代码的1、2输出是什么？"></a>首先想一下下面这段代码的1、2输出是什么？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">int i=100;</span><br><span class="line">printf(&quot;%d\n&quot;,i);     //1</span><br><span class="line">printf(&quot;%d\n&quot;,&amp;i);    //2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了相信大家都有自己的判断了。</p><p><code>int *pi;</code></p><p>上面这个应该 是最基础的了，pi就是指针我们当然知道了，但是你要说它与int pi; 有什么区别，它也没有，因为他也是变量，顶多叫指针声明（不能为叫申明），那他到底有什么意义呢？ 看下面：<br><br><code>pi = &amp;i;</code><br><br><br>这个应该都能看懂吧，通俗点讲就把变量 i 的地址编号赋值给 pi 。<br><br>如：</p><table><thead><tr><th align="center">变量</th><th align="center">内容</th><th align="center">内存地址编号</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">100</td><td align="center">7</td></tr><tr><td align="center">pi</td><td align="center">?</td><td align="center">10</td></tr></tbody></table><p>表格中 ? 该为多少，相信大家都会填，为<strong>7</strong>也就是i的地址编号。也就是说&amp;为取地址号操作，我们就把pi称为指针，所以要记住，指针变量所存的内容为地址编号就行了。</p><p>讲到这，我们再回归到上面的代码1处，都知道1处输出为<strong>100</strong>，那下面这句呢？<br><br><code>printf(&quot;%d\n&quot;,*pi);</code><br><br>这句该怎么理解呢，上面不是说了吗pi就是i的地址编号——即pi的内容就是<strong>7</strong>，所以*pi就是pi所指地址的内容了，也就是 i 内容了100它就等同于1处的代码了。</p><p>这些都是很基础的了，下面将一些难的，</p><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>一维数组a[i]中的a表示数组名，也可以表示a[0]的地址，它是等同于*a的<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d\n&quot;,a[i]);</span><br><span class="line">printf(&quot;%d\n&quot;,*(a+i));</span><br></pre></td></tr></table></figure><br>都表示遍历数组a[i]的，但是他们是有区别的<p><strong>a[]和*a的区别：</strong><br><br>char *a 与char a[] 的区别：<br></p><ul><li><p>char *a = “hello” 中的a是指向第一个字符‘h’的一个指针<br></p></li><li><p>char a[20] = “hello” 中数组名a也是执行数组第一个字符‘h’的指针</p></li></ul><p>但二者并不相同：</p><p>如：把两个字符串相加</p><p><img src="https://tvax4.sinaimg.cn/large/006p97Wqgy1gc7krqaswmj307p060745.jpg" alt="图片1"></p><p>结果：</p><p><img src="https://tva3.sinaimg.cn/large/006p97Wqgy1gc7ks5h2k9j303o00j0nz.jpg" alt="图片4"></p><p>对比：</p><p><img src="https://tva1.sinaimg.cn/large/006p97Wqgy1gc7ksjo5ghj307105y3yd.jpg" alt="图片3"></p><p>结果：</p><p><img src="https://tva3.sinaimg.cn/large/006p97Wqgy1gc7ksyt7i6j304h00j0m4.jpg" alt="图片5"></p><p>把字符串加到指针所指的字串上去，出现段错误，<font color="red">本质原因</font>：*d=”0123456789”存放在常量区，是无法修的。而数组是存放在<font color="red">栈</font>中，是可以修改的。两者区别如下：<br><br>一. ”读“ ”写“ 能力</p><ul><li>char *a = “abcd”;  此时”abcd”存放在常量区。通过指针只可以访问字符串常量，而不可以改变它。<br></li></ul><ul><li>而char a[20] = “abcd”； 此时 “abcd”存放在栈。可以通过指针去访问和修改数组内容。<br>二. 赋值时刻</li></ul><ul><li>char *a = “abcd”; 是在编译时就确定了（因为为常量）。</li></ul><ul><li>而char a[20] = “abcd”； 在运行时确定<br>三. 存取效率</li></ul><ul><li>char *a = “abcd”; 存于静态存储区。在栈上的数组比指针所指向字符串快。因此慢</li></ul><ul><li>而char a[20] = “abcd”； 存于栈上。快<br>另外注意：<br>char a[] = “01234”,虽然没有指明字符串的长度，但是此时系统已经开好了，就是大小为6—–’0’ ‘1’ ‘2’ ‘3’ ‘4’ ‘\0’，(注意strlen(a)是不计‘\0’)，也就是说字符串长度为5，但是字符串占有的空间为6。<br></li></ul><p>看一结构中出现的同样的问题：<br>这样红色部分在调用int函数时会出现“Segment Default”, 因为此时 指针n是静态的，只有“读”的本事，不可以改变。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;浅谈c语言灵魂——指针&quot;&gt;&lt;a href=&quot;#浅谈c语言灵魂——指针&quot; class=&quot;headerlink&quot; title=&quot;浅谈c语言灵魂——指针&quot;&gt;&lt;/a&gt;浅谈c语言灵魂——指针&lt;/h2&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;c语言什么最难，当然是指针(Pointer)，c语言之所以强大，以及其自由性，很大部分体现在其灵活的指针运用上。因此，说指针是c语言的灵魂，一点都不为过。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C语言" scheme="https://makejiec.gitee.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="指针" scheme="https://makejiec.gitee.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>关于七牛云图床的使用</title>
    <link href="https://makejiec.gitee.io/2019/08/19/20190819/"/>
    <id>https://makejiec.gitee.io/2019/08/19/20190819/</id>
    <published>2019-08-19T11:47:56.000Z</published>
    <updated>2020-02-24T08:33:01.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于七牛云的使用"><a href="#关于七牛云的使用" class="headerlink" title="关于七牛云的使用"></a>关于七牛云的使用</h2><meta name="referrer" content="no-referrer"><p>在网站的访问过程中，由于要使用图片才能显现美观，但图片过多时就会降低网站的访问进程，增加访问的时间，所以我们就要把图片同一处理，放在一个图床里单独访问，但是自己配一个服务器又要钱，买一个云储存对象很贵，这里介绍了七牛云，每个月免费10G的存储空间，非常适合小型博客网站，相册的使用。</p><a id="more"></a><h4 id="1、注册七牛云"><a href="#1、注册七牛云" class="headerlink" title="1、注册七牛云"></a>1、注册<a href="https://portal.qiniu.com/signup" target="_blank" rel="noopener">七牛云</a></h4><p>进入主页点击：<br>为了更直观 我截图来说明</p><p><img src="https://tva2.sinaimg.cn/large/006p97Wqgy1gc7kmcbtm1j30zn0ragoe.jpg" alt="QQ图片20190820192645"></p><p><img src="https://tvax1.sinaimg.cn/large/006p97Wqgy1gc7kmt3p9uj314a0jsgng.jpg" alt="QQ图片20190820192652"></p><h4 id="2、创建好后我们可以看到"><a href="#2、创建好后我们可以看到" class="headerlink" title="2、创建好后我们可以看到"></a>2、创建好后我们可以看到</h4><p><img src="https://tva3.sinaimg.cn/large/006p97Wqgy1gc7kn7mh5tj311x0hwjsu.jpg" alt="QQ图片20190820192658"></p><p> <strong>记住这个域名</strong><br>虽然这旁边有上传文件，把图片上床后就会形成一个URL地址<br>然后你的代码里添加这个URL就可以加载图片了，但是非常麻烦每次都要打开这个网站传，所以这里介绍一个插件PicGo，大家可以到我<a href="https://github.com/jirouping/PicGo" target="_blank" rel="noopener">github</a>上下载。特别感谢PicGo大佬的插件。</p><p>然后配置PicGo插件：</p><p>1、网址为上图里的默认域名 </p><p>2、AK和SK进密钥管理看</p><p><img src="https://tvax2.sinaimg.cn/large/006p97Wqgy1gc7ko1ptbtj30f70fwq3h.jpg" alt="QQ图片20190820192701"></p><h4 id="Next"><a href="#Next" class="headerlink" title="Next:"></a>Next:</h4><p><img src="http://pwbwgsn9c.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720190820194407.png" alt="5"></p><h4 id="配置七牛图床"><a href="#配置七牛图床" class="headerlink" title="配置七牛图床:"></a>配置七牛图床:</h4><p><img src="https://tva4.sinaimg.cn/large/006p97Wqgy1gc7kqcoyikj30rx0ftjsu.jpg" alt="QQ图片20190820194747"></p><p>配置好后进去上传区，上传图片。然后在相册区复制不同类型的URL</p><p>这就是一些七牛云的操作。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于七牛云的使用&quot;&gt;&lt;a href=&quot;#关于七牛云的使用&quot; class=&quot;headerlink&quot; title=&quot;关于七牛云的使用&quot;&gt;&lt;/a&gt;关于七牛云的使用&lt;/h2&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;在网站的访问过程中，由于要使用图片才能显现美观，但图片过多时就会降低网站的访问进程，增加访问的时间，所以我们就要把图片同一处理，放在一个图床里单独访问，但是自己配一个服务器又要钱，买一个云储存对象很贵，这里介绍了七牛云，每个月免费10G的存储空间，非常适合小型博客网站，相册的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="七牛云" scheme="https://makejiec.gitee.io/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    
      <category term="插件" scheme="https://makejiec.gitee.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="PicGo" scheme="https://makejiec.gitee.io/tags/PicGo/"/>
    
  </entry>
  
  <entry>
    <title>yilia主题的一些配置问题</title>
    <link href="https://makejiec.gitee.io/2019/08/17/20190817/"/>
    <id>https://makejiec.gitee.io/2019/08/17/20190817/</id>
    <published>2019-08-17T04:02:21.000Z</published>
    <updated>2020-02-24T08:28:28.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="页面点击爱心和网站访问数量的实现"><a href="#页面点击爱心和网站访问数量的实现" class="headerlink" title="页面点击爱心和网站访问数量的实现"></a>页面点击爱心和网站访问数量的实现</h2><meta name="referrer" content="no-referrer"><p>为了完善自己更好看的博客，对原始主题进行了一些小的修改</p><a id="more"></a><h5 id="页面点击出现爱心的实现"><a href="#页面点击出现爱心的实现" class="headerlink" title="页面点击出现爱心的实现"></a>页面点击出现爱心的实现</h5><p>在这里我加了一些js代码让页面显示更炫酷，文件我上传到了<u><a href="https://github.com/jirouping/yilia-love/blob/master/love.js" target="_blank" rel="noopener"><strong>我的github</strong></a></u>里大家可以复制下来，然后新建一个<u><strong><em>love.js</em></strong></u>文件加在<font color="orange" size="4">\blog\themes\yilia\source</font>里，接着在你的<font color="orange" size="4">\blog\themes\yilia\layout\_partial\footer.ejs</font>的最后面加入以下代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/love.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="页面访问次数的实现"><a href="#页面访问次数的实现" class="headerlink" title="页面访问次数的实现"></a>页面访问次数的实现</h4><p>这里我是使用<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a>来实现的，首先同在你的<font color="orange" size="4">\blog\themes\yilia\layout_partial\footer.ejs</font>加入如下代码：</p><p><img src="https://tva1.sinaimg.cn/large/006p97Wqgy1gc7kkp42fjj30on0abgma.jpg" alt="QQ图片20190817202816"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 自己加一个div</span><br><span class="line">&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class="line"> 本站访客数：&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人 |</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;</span><br><span class="line">本文总阅读量：&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>再在最后加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>最后面实现：</p><h2 id><a href="#" class="headerlink" title></a><img src="https://tvax2.sinaimg.cn/large/006p97Wqgy1gc7klmgi5gj30kd02imx0.jpg" alt="QQ图片20190817202810"></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;页面点击爱心和网站访问数量的实现&quot;&gt;&lt;a href=&quot;#页面点击爱心和网站访问数量的实现&quot; class=&quot;headerlink&quot; title=&quot;页面点击爱心和网站访问数量的实现&quot;&gt;&lt;/a&gt;页面点击爱心和网站访问数量的实现&lt;/h2&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;为了完善自己更好看的博客，对原始主题进行了一些小的修改&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://makejiec.gitee.io/tags/hexo/"/>
    
      <category term="yilia" scheme="https://makejiec.gitee.io/tags/yilia/"/>
    
  </entry>
  
  <entry>
    <title>考研日常记</title>
    <link href="https://makejiec.gitee.io/2019/08/16/20190816/"/>
    <id>https://makejiec.gitee.io/2019/08/16/20190816/</id>
    <published>2019-08-16T14:18:43.000Z</published>
    <updated>2021-01-02T12:46:20.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="梦里花落知多少"><a href="#梦里花落知多少" class="headerlink" title="梦里花落知多少"></a>梦里花落知多少</h2><meta name="referrer" content="no-referrer">积极的人在每一次忧患中都看到一个机会，而消极的人则在每个机会都会看某种忧患<a id="more"></a>今天又慌废了一天，我想大概是我校园卡掉了的原因，心情特别不好，下午在教室总是心在焉。大概我就是消极的人，每次有一点不好的事情都会忧心忡忡，可能与性格相关，单身加计算机专业宅男，还很内向，不好交流，每次的所见所感都是talk to myself。<br>想到一个有意思的单词前天在看朱伟老师的单词视频 —— Independent，所以可以叫我Mr.Independent吧<br><br><p><img src="https://tvax1.sinaimg.cn/large/006p97Wqgy1gc7kjofqr9j356o3ggu0y.jpg" alt="风景"></p><br><p>回到寝室写了篇博客记录下，心情好了点，这大概就是所谓的发泄吧，把自己的心情写给陌生的网友看，我不像一些QQ好友一样鸡毛蒜皮的小事也会发一个说说来言于他人，我可是高贵的强者。<br><br></p><p>所以不管干什么都会又压力，有挫折，但要去发泄出来才能换来明天的好心情。<br><br><br>祝愿明天有个好心情，考研路上很多绊脚石，只有一点一点来，按自己的思路来。</p><p>物是人非事事休，欲语泪先流。<br>最后记录一首卢前的词——《梦花落知多少》：<br><br><br>记得当时年纪小，你爱谈天我爱笑，有一回并肩坐在桃树下，风在树梢鸟在叫，我不知怎样睡着了，梦里花落知多少。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;梦里花落知多少&quot;&gt;&lt;a href=&quot;#梦里花落知多少&quot; class=&quot;headerlink&quot; title=&quot;梦里花落知多少&quot;&gt;&lt;/a&gt;梦里花落知多少&lt;/h2&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
积极的人在每一次忧患中都看到一个机会，而消极的人则在每个机会都会看某种忧患
    
    </summary>
    
    
      <category term="随笔" scheme="https://makejiec.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="考研" scheme="https://makejiec.gitee.io/tags/%E8%80%83%E7%A0%94/"/>
    
      <category term="感悟" scheme="https://makejiec.gitee.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="Independent" scheme="https://makejiec.gitee.io/tags/Independent/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客的搭建之旅</title>
    <link href="https://makejiec.gitee.io/2019/08/12/20190812/"/>
    <id>https://makejiec.gitee.io/2019/08/12/20190812/</id>
    <published>2019-08-12T13:01:37.000Z</published>
    <updated>2020-02-24T08:25:50.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo-阿里云（centos7-x）-git"><a href="#hexo-阿里云（centos7-x）-git" class="headerlink" title="hexo+阿里云（centos7.x）+git"></a>hexo+阿里云（centos7.x）+git</h2><meta name="referrer" content="no-referrer"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>拥有个人的博客是每个程序员的想法，我也一样所以看到最近看到hexo的博客，心血来潮，查一下，hexo是一个轻量的博客框架，</p><a id="more"></a><p>对于一个没学过数据库，只自学一点mysql和php的嵌入式的同学非常方便。之前也用过LAMP+腾讯云的方式搭建过wordpress博客，这个博客有后台数据库等（搭建很简单），但死于主题的选择，换了博客，个人感觉hexo主题比较美观可以自己添加很多功能所以选择这个轻量级的博客。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>虽然hexo的简便，但是安装起来可是花费我好几天的时间，比wordpress难。所以写了一个小结，帮助后面的小伙伴们安装。</p><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="(1)准备工作"></a>(1)准备工作</h3><h4 id="先从本地环境开始安装需要的配置-我的电脑是Win10-64位"><a href="#先从本地环境开始安装需要的配置-我的电脑是Win10-64位" class="headerlink" title="先从本地环境开始安装需要的配置(我的电脑是Win10  64位)"></a>先从本地环境开始安装需要的配置(我的电脑是Win10  64位)</h4><p> <font color="#FF0000" size="4"><strong>需要安装的:</strong></font></p><ul><li><p>Git：<a href="https://git-scm.com/" title="Git官网" target="_blank" rel="noopener">https://git-scm.com/</a></p></li><li><p>Notepad++：你喜欢用什么就用什么(记事本也行但是后面改东西时会很乱）这里我推荐用Notepad++</p></li><li><p>Node.js：<a href="http://nodejs.cn/download/" title="Node.js下载" target="_blank" rel="noopener">http://nodejs.cn/download/</a> </p></li><li><p>npm：npm是node的模块管理工具，淘宝镜像地址(<a href="http://npm.taobao.org/" target="_blank" rel="noopener">http://npm.taobao.org</a>/)</p></li></ul><p>你还要有github账号(没有就去申请)</p><h4 id="下载完后需要进行配置-这里就不多讲了自己查查资料很简单的"><a href="#下载完后需要进行配置-这里就不多讲了自己查查资料很简单的" class="headerlink" title="下载完后需要进行配置(这里就不多讲了自己查查资料很简单的)"></a>下载完后需要进行配置(这里就不多讲了自己查查资料很简单的)</h4><p>安装完成的截图：<br><img src="https://tva1.sinaimg.cn/large/006p97Wqgy1gc7kcbn2zhj30g70dfaap.jpg" alt="1"></p><p>当出现上图时表示安装好了  Next！</p><h3 id="2-服务器环境搭建"><a href="#2-服务器环境搭建" class="headerlink" title="(2)服务器环境搭建"></a>(2)服务器环境搭建</h3><ul><li><h4 id="第一步安装Git-好像Ubuntu自带git，没用过带哥们可以试试"><a href="#第一步安装Git-好像Ubuntu自带git，没用过带哥们可以试试" class="headerlink" title="第一步安装Git(好像Ubuntu自带git，没用过带哥们可以试试)"></a>第一步安装Git(好像Ubuntu自带git，没用过带哥们可以试试)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version  //如果有就不用安装直接跳过这一步</span><br><span class="line">yum install git</span><br></pre></td></tr></table></figure></li><li><h4 id="创建git用户"><a href="#创建git用户" class="headerlink" title="创建git用户"></a>创建git用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">useradd git     //创建用户</span><br><span class="line">passwd git     //设置密码</span><br><span class="line">su git               //切换用户</span><br><span class="line">cd /home/git/</span><br><span class="line">mkdir -p projects/blog          //项目的目录</span><br><span class="line">mkdir repos &amp;&amp;cd repos      </span><br><span class="line">git init --bare blog.git           //创建一个空的仓库</span><br><span class="line">cd  blog.git/hooks         </span><br><span class="line">vim  post-receive                 //创建一个钩子函数</span><br></pre></td></tr></table></figure></li></ul><p>输入下面的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">git --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f</span><br></pre></td></tr></table></figure><p>输入完后修改权限，输入下面命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x post-receive</span><br><span class="line">exit   //退出登录  </span><br><span class="line">chown -R git:git /home/git/repos/blog.git</span><br></pre></td></tr></table></figure><p><font color="#FF0000" size="5"><strong><em>注：</em></strong></font><br><font color="#FF0000" size="4"><em>由于没有在etc/sudoers里面添加git     ALL=(ALL)       ALL，所以有的命令不能使用，只能严格按照前面的来</em></font></p><p>全部弄好后就要测试下了：<br>首先你要在一个空白地方建立一个你要clone下git仓库的文件夹如：B:/test然后在本地用Git进入你的文件夹，然后执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@你的服务器ip:/home/git/repos/blog.git</span><br></pre></td></tr></table></figure><p>出现下图就算成功了</p><p><img src="https://tva1.sinaimg.cn/large/006p97Wqgy1gc7kavyx33j30h6095gls.jpg" alt="2"><br><img src="https://tva2.sinaimg.cn/large/006p97Wqgy1gc7kb7ple1j30kp0eg3zd.jpg" alt="3"></p><h3 id="3-建立ssh信任"><a href="#3-建立ssh信任" class="headerlink" title="(3)建立ssh信任"></a>(3)建立ssh信任</h3><p>创建公共秘钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;      //你的github名字，如我的：jirouping</span><br><span class="line">git config --global user.email &quot;youremail&quot;      //你的github绑定的邮箱，如你注册使用的QQ邮箱</span><br></pre></td></tr></table></figure><p>然后不用管直接回车，next：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p>生成的<font color="#FF0000"><strong>.ssh</strong></font>文件，在你电脑里找，一般在C:/user/…下，不同的电脑不一样<br><img src="https://tvax2.sinaimg.cn/large/006p97Wqgy1gc7kcnd6ttj30oc072jrs.jpg" alt="4"></p><p>看到上图就可以了接着建立信任了在本地的Git Bash上输入： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i C:/Users/yourname/.ssh/id_rsa.pub git@server_ip</span><br><span class="line">ssh git@server_ip // 测试能否登录</span><br></pre></td></tr></table></figure><p><font color="#FF0000" size="3">这时候可以连接你的服务器了是不要密码的！否则就检查下上面的步骤</font><br>当成功连接后，我们知道了以后就可以通过ssh来连接你的服务，虽然不是在root下，但还是存在问题</p><p>那我们就用可以设置限制git用户登录让他只能传输和clone文件<br>在服务器上操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells           // 查看`git-shell`是否在登录方式里面，有则跳过</span><br><span class="line">which git-shell         // 查看是否安装</span><br><span class="line">vim /etc/shells</span><br><span class="line">在后面添加上2步显示出来的路劲，通常在 /usr/bin/git-shell</span><br></pre></td></tr></table></figure><p>然后修改下<font color="#FF0000">/etc/passwd/</font>的权限，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /etc</span><br><span class="line">vim passwd         </span><br><span class="line">修改原来的：</span><br><span class="line">git:x:1000:1000::/home/git:/bin/bash</span><br><span class="line"></span><br><span class="line">改成：</span><br><span class="line">git:x:1000:1000::/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><h3 id="4-搭建nginx服务器"><a href="#4-搭建nginx服务器" class="headerlink" title="(4)搭建nginx服务器"></a>(4)搭建nginx服务器</h3><ul><li>安装和启动nginx:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx -y       //安装</span><br><span class="line">systemctl start nginx     //这是CentOs7.x启动方式，也有其他的如：./nginx</span><br><span class="line">systemctl enable nginx     //设置开机自启</span><br></pre></td></tr></table></figure></li></ul><p>装好后，就可访问你的界面了（出现什么welcome tonginx一个蓝色框就对了）注意看英文（很简单的应该都看得懂）里面有nginx的配置文件的路径记下来，一般是/etc/nginx/nginx.conf ,如果是其他版本的自己注意下页面里的内容。</p><ul><li>修改配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop // 先停止nginx</span><br><span class="line">cd /etc/nginx</span><br><span class="line">vim nginx.conf</span><br><span class="line"></span><br><span class="line">修改 root 解析路径，如下图</span><br><span class="line">同时将 user 改为 root 如下图，不然nginx无法访问 /home/git/project/blog</span><br><span class="line"></span><br><span class="line">systemctl start nginx      //启动nginx</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://tva3.sinaimg.cn/large/006p97Wqgy1gc7kcyis1yj30ce07uaaa.jpg" alt="5"></p><p><img src="https://tva3.sinaimg.cn/large/006p97Wqgy1gc7kdaql44j30js0c1gmh.jpg" alt="6"></p><p>到此服务器端就算好了！！</p><h3 id="5-Hexo博客的安装"><a href="#5-Hexo博客的安装" class="headerlink" title="(5)Hexo博客的安装"></a>(5)Hexo博客的安装</h3><ul><li>安装hexo<br>在git-for-windows上面运行下面的语句（git-for-windows版本要高于2.12）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g      #使用全局设置下载、安装hexo至默认的文件夹</span><br><span class="line">hexo init blog                      #在当前文件夹下初始化一个blog项目，从远程git仓库拷贝</span><br><span class="line">cd blog                                 #进入blog</span><br><span class="line">npm install                           #安装指定模块，package.json指定</span><br><span class="line">hexo g</span><br><span class="line">hexo server                          #打开服务</span><br></pre></td></tr></table></figure></li></ul><p>用浏览器打开：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 出现下面这样就好了<br><img src="https://tva3.sinaimg.cn/large/006p97Wqgy1gc7kdmtmo4j30y80gdaio.jpg" alt="7"></p><p>在package.json文件中添加npm脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;deploy&quot;: &quot;hexo clean &amp;&amp; hexo g -d&quot;,</span><br><span class="line">  &quot;start&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tvax4.sinaimg.cn/large/006p97Wqgy1gc7kdwt3jqj30ii09xdg8.jpg" alt="8"></p><p>然后直接用npm命令就可以本地调试和上传服务器了<br>本地调试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure><p>修改博客主目录的配置文件：_config.yml来上传至服务器<br><img src="https://tvax3.sinaimg.cn/large/006p97Wqgy1gc7keob2hqj30gd059t8w.jpg" alt="10"></p><p><img src="https://tva1.sinaimg.cn/large/006p97Wqgy1gc7ke5fousj30k004kdg2.jpg" alt="9"></p><p>直接照着上图填开始deploy属性里面只有type，后面的repo和branch是自己添加上去的（别慌，不要以为自己没下完整）<br><font color="#FF0000" size="6"><strong><em>注：</em></strong></font>在deploy里添加东西时之间要加空格 (<font color="#FF0000"><strong><em>如:git与:之间有空格</em></strong></font>)没加就会出错，传不到服务器</p><p>然后上传服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run deploy</span><br></pre></td></tr></table></figure><p>浏览器访问下你的域名和ip就可以看到了</p><p>故事到这接结束了，花了我好几天总算有点成果了，希望对你有帮助</p><h2 id="有问题可以加我一起讨论。"><a href="#有问题可以加我一起讨论。" class="headerlink" title="有问题可以加我一起讨论。"></a>有问题可以加我一起讨论。</h2><div align="center"> <img src="https://tva2.sinaimg.cn/large/006p97Wqgy1gc7kibbprej30kw0r2jt6.jpg" alt="vxprofile" width="300"></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;hexo-阿里云（centos7-x）-git&quot;&gt;&lt;a href=&quot;#hexo-阿里云（centos7-x）-git&quot; class=&quot;headerlink&quot; title=&quot;hexo+阿里云（centos7.x）+git&quot;&gt;&lt;/a&gt;hexo+阿里云（centos7.x）+git&lt;/h2&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;拥有个人的博客是每个程序员的想法，我也一样所以看到最近看到hexo的博客，心血来潮，查一下，hexo是一个轻量的博客框架，&lt;/p&gt;
    
    </summary>
    
    
      <category term="阿里云" scheme="https://makejiec.gitee.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="hexo" scheme="https://makejiec.gitee.io/tags/hexo/"/>
    
  </entry>
  
</feed>
